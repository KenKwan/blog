# Host: localhost  (Version 5.7.14-log)
# Date: 2016-09-17 23:37:40
# Generator: MySQL-Front 5.4  (Build 1.6)

/*!40101 SET NAMES utf8 */;

#
# Structure for table "article"
#

DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `articleId` int(20) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) NOT NULL,
  `articleType` int(11) NOT NULL,
  `summary` varchar(1024) DEFAULT NULL,
  `content` text NOT NULL,
  `createBy` varchar(32) NOT NULL,
  `createTime` mediumtext NOT NULL,
  `lastUpdBy` varchar(32) NOT NULL,
  `lastUpdTime` mediumtext NOT NULL,
  PRIMARY KEY (`articleId`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4;

#
# Data for table "article"
#

INSERT INTO `article` VALUES (1,'编译原理：求First集和Follow集',1,'文法： S→ABc  A→a|ε  B→b|ε','<p><span style=\"color: rgb(57, 67, 50); line-height: 28px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; background-color: rgb(255, 255, 255);\">文法：</span></p><p><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(57, 67, 50); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; line-height: 28px; background-color: rgb(255, 255, 255);\"><em style=\"line-height: 28px; color: rgb(0, 128, 255); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; white-space: normal; background-color: rgb(255, 255, 255);\"><strong>S→ABc</strong></em></span></span></p><p><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(57, 67, 50); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; line-height: 28px; font-size: 16px; background-color: rgb(255, 255, 255);\"><em style=\"line-height: 28px; color: rgb(0, 128, 255); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; white-space: normal; background-color: rgb(255, 255, 255);\"><strong>A→a|ε</strong></em></span></span></p><p><span style=\"font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"color: rgb(57, 67, 50); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; line-height: 28px; font-size: 16px; background-color: rgb(255, 255, 255);\"><em style=\"line-height: 28px; color: rgb(0, 128, 255); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; white-space: normal; background-color: rgb(255, 255, 255);\"><strong>B→b|ε</strong></em></span></span></p><p><span style=\"color: rgb(57, 67, 50); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; line-height: 28px; background-color: rgb(255, 255, 255);\"><em style=\"line-height: 28px; color: rgb(0, 128, 255); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; white-space: normal; background-color: rgb(255, 255, 255);\"><strong><br/></strong></em></span></p><p><span style=\"color: rgb(57, 67, 50); line-height: 28px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; background-color: rgb(255, 255, 255);\">First集合求法:</span></p><p><span style=\"color: rgb(57, 67, 50); line-height: 28px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: rgb(255, 255, 255);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能由非终结符号推出的所有的开头符号或可能的ε，但要求这个开头符号是终结符号。如此题A可以推导出a和ε，所以FIRST（A）=｛a，ε｝；同理FIRST（B）={b,ε};S可以推导出aBc，还可以推导出bc，还可以推导出c，所以FIRST(S）=｛a，b，c｝</span></p><p><span style=\"color: rgb(57, 67, 50); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; line-height: 28px; font-size: 16px; background-color: rgb(255, 255, 255);\"><br/></span></p><p><span style=\"color: rgb(57, 67, 50); line-height: 28px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; background-color: rgb(255, 255, 255);\">Follow集合的求法:</span></p><p><span style=\"color: rgb(57, 67, 50); line-height: 28px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: rgb(255, 255, 255);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;紧跟随其后面的终结符号或＃。但文法的识别符号包含＃，在求的时候还要考虑到ε。 具体做法是把所有包含你要求的符号的产生式都找出来，再看哪个有用。 Follow（S）=｛＃｝</span></p><p><span style=\"color: rgb(57, 67, 50); line-height: 28px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: rgb(255, 255, 255);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如求A的，产生式：S→ABc A→a|ε ，但只有S→ABc 有用。跟随在A后年的终结符号是FIRST（B）=｛b，ε｝，当FIRST（B）的元素为ε时，跟随在A后的符号就是c，所以 Follow（A）=｛b，c｝ 同理Follow（B）=｛c｝</span></p><p><span style=\"color: rgb(57, 67, 50); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; line-height: 28px; background-color: rgb(255, 255, 255);\"><em style=\"line-height: 28px; color: rgb(0, 128, 255); font-family: &#39;Hiragino Sans GB W3&#39;, &#39;Hiragino Sans GB&#39;, Arial, Helvetica, simsun, u5b8bu4f53; white-space: normal; background-color: rgb(255, 255, 255);\"><strong><br/></strong></em></span></p>','Admin','1450100006503','Admin','1450100006503'),(2,'只针对异常的情况才使用异常',1,'第57条：只针对异常的情况才使用异常。异常时为了在异常的情况下使用而设计的。不能将它们用于普通的控制流，也不要编写迫使它们这么做的API','<p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">先看两个对数组元素进行遍历的实现方式：</span></p><pre class=\"brush:java;toolbar:false\">//&nbsp;1.&nbsp;基于异常的循环模式，不要这样做\ntry&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;while(true)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;range[i++].climb();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}&nbsp;catch(ArrayIngexOutOfBoundsException&nbsp;e)&nbsp;{\n}\n\n//&nbsp;2.&nbsp;标准模式\nfor(Mountain&nbsp;m&nbsp;:&nbsp;range)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;m.climb();\n}</pre><p><br/></p><p style=\"line-height: normal;\"><span style=\"font-family: 宋体, SimSun;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">基于异常的循环模式不仅模糊了代码的意图，降低了它的性能，而且它还不能保证正常工作！</span></span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br/></span></p><p style=\"line-height: 1.5em;\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;如果出现了不相关的Bug，这个模式会悄悄的失效，掩盖了这个Bug，极大的增加了调试过程的复杂性。假设循环体的计算过程调用了一个方法，这个方法执行了对某个不相关的数组的越界访问。如果使用标准的循环模式，这个Bug会产生未被捕捉的异常，从而导致线程中断立即结束，产生完整的堆栈信息。而使用了这个基于异常的循环模式，这个Bug相关的异常会被捕捉到，而且错误的被认为是正常的循环终止条件。</span></p><p><br/></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;总之，<strong>异常时为了在异常的情况下使用而设计的。不能将它们用于普通的控制流，也不要编写迫使它们这么做的API。</strong></span></p>','Admin','1450623688625','Admin','1450623688625'),(3,'最后一个单词的长度',2,'计蒜客：12 最后一个单词的长度','<div class=\"inbox\" style=\"box-sizing: border-box; padding-bottom: 7px; color: rgb(51, 51, 51); font-family: &#39;Segoe UI&#39;, &#39;Helvetica Neue&#39;, &#39;Lucida Grande&#39;, Helvetica, Arial, &#39;Open Sans&#39;, &#39;Hiragino Sans GB&#39;, &#39;wenquanyi micro hei&#39;, &#39;Microsoft YaHei&#39;, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(213, 217, 224);\"><span id=\"description\" style=\"box-sizing: border-box;\"><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">时间限制：1000ms&nbsp;&nbsp;&nbsp;&nbsp;内存限制：65536K</span></p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">给定由大写，小写字母和空格组成的字符串，返回<span style=\"box-sizing: border-box; font-weight: 700; padding: 10px 0px;\">最后</span>一个单词的长度。<br/></p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">如果不存在最后一个单词，返回0</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">注意：</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">&nbsp; &nbsp;“单词”是指不包含空格符号的字符串</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">例如：</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">&nbsp; &nbsp;s = “hello World”, 那么返回的结果是5</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">格式：</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">&nbsp; &nbsp;第一行输入字符串s，然后输出s中最后一个单词的长度。</p></span></div><h4 class=\"title\" style=\"box-sizing: border-box; margin: 0px; font-size: 18px; font-family: &#39;Segoe UI&#39;, &#39;Helvetica Neue&#39;, &#39;Lucida Grande&#39;, Helvetica, Arial, &#39;Open Sans&#39;, &#39;Hiragino Sans GB&#39;, &#39;wenquanyi micro hei&#39;, &#39;Microsoft YaHei&#39;, sans-serif; line-height: 1.1; color: rgb(51, 51, 51); padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; white-space: normal; background-color: rgb(213, 217, 224);\">样例1</h4><div class=\"inbox none\" style=\"box-sizing: border-box; padding-bottom: 7px; color: rgb(51, 51, 51); font-family: &#39;Segoe UI&#39;, &#39;Helvetica Neue&#39;, &#39;Lucida Grande&#39;, Helvetica, Arial, &#39;Open Sans&#39;, &#39;Hiragino Sans GB&#39;, &#39;wenquanyi micro hei&#39;, &#39;Microsoft YaHei&#39;, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(213, 217, 224);\"><div class=\"example\" style=\"box-sizing: border-box; padding-bottom: 7px;\"><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">输入：</p><pre class=\"\" style=\"box-sizing: border-box; line-height: 24px; margin-top: 0px; margin-bottom: 0px; font-size: 16px; white-space: pre-wrap; padding: 5px 10px; word-break: break-word; word-wrap: break-word; color: rgb(233, 30, 99); border: 1px solid rgb(204, 204, 204); border-radius: 4px; overflow: auto; -webkit-font-smoothing: antialiased; font-family: Menlo, Monaco, Consolas, &#39;Courier New&#39;, monospace !important; background-color: rgb(230, 230, 230);\">Today&nbsp;is&nbsp;a&nbsp;nice&nbsp;day</pre></div><div class=\"example\" style=\"box-sizing: border-box; padding-bottom: 7px;\"><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 0px; padding: 0px 0px 7px; word-break: break-word; -webkit-font-smoothing: antialiased; line-height: 28px; font-size: 16px;\">输出：</p><pre class=\"\" style=\"box-sizing: border-box; line-height: 24px; margin-top: 0px; margin-bottom: 0px; font-size: 16px; white-space: pre-wrap; padding: 5px 10px; word-break: break-word; word-wrap: break-word; color: rgb(233, 30, 99); border: 1px solid rgb(204, 204, 204); border-radius: 4px; overflow: auto; -webkit-font-smoothing: antialiased; font-family: Menlo, Monaco, Consolas, &#39;Courier New&#39;, monospace !important; background-color: rgb(230, 230, 230);\">3</pre></div></div><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">解题思路：</span><br/></p><p>&nbsp; &nbsp;<span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"> 1. 先去除字符串两头的空格<br/></span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;2. 根据最后一个空格截取字符串</span></p><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">Java代码：</span><a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/q/jisuanke/Main12.java\" target=\"_blank\" title=\"最后一个单词长度\" style=\"text-decoration: underline; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">源代码</span></a></p><pre class=\"brush:java;toolbar:false\">public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;Scanner&nbsp;sc&nbsp;=&nbsp;new&nbsp;Scanner(System.in);\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sc.hasNext())&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s&nbsp;=&nbsp;sc.nextLine();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(getLastWordLen(s));\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(0);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}\n\nprivate&nbsp;static&nbsp;int&nbsp;getLastWordLen(String&nbsp;str)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len&nbsp;=&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(null&nbsp;!=&nbsp;str)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;=&nbsp;str.trim();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n\tif&nbsp;(!&quot;&quot;.equals(str))&nbsp;{\n\t&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;=&nbsp;str.substring(str.lastIndexOf(&quot;&nbsp;&quot;)&nbsp;+&nbsp;1,&nbsp;str.length()).length();\n\t}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;len;\n}</pre><p><br/></p><p><a href=\"http://nanti.jisuanke.com/t/12\" target=\"_blank\" title=\"计蒜客\" textvalue=\"计蒜客\" style=\"text-decoration: underline; font-size: 14px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><span style=\"font-size: 14px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">题目链接</span></a></p>','Admin','1451376675313','Admin','1451376675313'),(4,'选择排序',1,'首先， 找到数组中最小的元素，将它和数组的第一个元素交换，再次，在剩余的元素中找到最小的元素并与数组的第二个元素交换，如此循环查找，直到数组排序号。','<p><span style=\"font-size: 22px;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">算法描述</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">：</span></span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;首先， 找到数组中最小的元素，将它和数组的第一个元素交换，再次，在剩余的元素中找到最小的元素并与数组的第二个元素交换，如此循环查找，直到数组排序号。</span></p><p><br/></p><p><span style=\"font-size: 22px;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Java代码实现</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">：</span></span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/algomrithm/Selection.java\" target=\"_blank\" textvalue=\"GitHub完整代码\" se_prerender_url=\"complete\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">源代码</span></a><br/></span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;static&nbsp;&lt;T&gt;&nbsp;void&nbsp;sort(Comparable&lt;T&gt;[]&nbsp;a)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;a.length;\n&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;min&nbsp;=&nbsp;i;\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;i&nbsp;+&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;n;&nbsp;j++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(less(a[j],&nbsp;a[min]))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min&nbsp;=&nbsp;j;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;exch(a,&nbsp;i,&nbsp;min);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n}</pre><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"></span><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">算法分析：</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;1.运行时间和输入无关。数组的一遍扫描并不能跟下一遍扫描提供有用信息，所以对于有序数组和主键相等的数组和无序数组所用的排序时间一样。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;2.数据移动是最小的。每次移动都是交换两个元素的值，所以排序用了N次交换。（交换次数和数组大小成线性关系是选择排序特有的）</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br/></span></p><p><br/></p><table data-sort=\"sortDisabled\" width=\"-306\"><tbody><tr class=\"firstRow\"><td valign=\"top\" rowspan=\"1\" colspan=\"3\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong>时间复杂度</strong><br/></span></td><td width=\"132\" valign=\"top\" rowspan=\"2\" colspan=\"1\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong>空间复杂度</strong><br/></span></td><td width=\"132\" valign=\"top\" rowspan=\"2\" colspan=\"1\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong>稳定性</strong><br/></span></td></tr><tr><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong>平均情况</strong></span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong>最坏情况</strong></span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong>最好情况</strong></span></td></tr><tr><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n<sup>2</sup>)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n<sup>2</sup>)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n<sup>2</sup>)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(1)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不稳定</span></td></tr></tbody></table><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">1.比较次数与序列的初始状态无关，较次数总是N (N - 1) / 2<br/></span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">2.移动次数与序列的初始状态有关，</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;当序列正序时，移动次数为0；</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">&nbsp;&nbsp;&nbsp;&nbsp;当序列反序时，移动次数最多，为3N (N - 1) / 2。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">3.排序需只要占用一个临时空间，在交换数值时使用，所以空间复杂度为O(1)</span></p>','Admin','1452688302143','Admin','1452688302143'),(5,'解决Nginx代理Tomcat的session丢失问题',1,'使用Nginx代理Tomcat，拦截器失效。浏览器firebug上看到每次访问的JSESSIONID都发生变化，造成每次访问都创建新的session。','<p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">起因</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">使用Nginx代理Tomcat，拦截器失效。浏览器firebug上看到每次访问的JSESSIONID都发生变化，造成每次访问都创建新的session。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">Nginx配置：</span><br/></p><pre class=\"brush:plain;toolbar:false;\">location&nbsp;=&nbsp;/&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://tomcat_proxy/test/;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$host;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;X-Real-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$remote_addr;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;X-Forwarded-For&nbsp;&nbsp;$proxy_add_x_forwarded_for;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">此配置会导致cookie存储的位置不是基于“/”，再次访问的时候会从新创建session，因此session中的信息丢失。</span></p><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">解决方法</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">修改cookie存储路径</span></p><pre class=\"brush:plain;toolbar:false\">location&nbsp;=&nbsp;/&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://tomcat_proxy/test/;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;Host&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$host;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;X-Real-IP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$remote_addr;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;&nbsp;X-Forwarded-For&nbsp;&nbsp;$proxy_add_x_forwarded_for;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_cookie_path&nbsp;/test/&nbsp;/;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;proxy_set_header&nbsp;Cookie&nbsp;$http_cookie;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p><br/></p>','Admin','1453363291627','Admin','1453363291627'),(7,'Java习惯用法总结',1,'在Java编程中，有些知识 并不能仅通过语言规范或者标准API文档就能学到的。在本文中，我会尽量收集一些最常用的习惯用法，特别是很难猜到的用法。（Joshua Bloch的《Effective Java》对这个话题给出了更详尽的论述，可以从这本书里学习更多的用法。）','<p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">实现equals()</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br/></span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">class&nbsp;Person&nbsp;{\n&nbsp;&nbsp;String&nbsp;name;\n&nbsp;&nbsp;int&nbsp;birthYear;\n&nbsp;&nbsp;byte[]&nbsp;raw;\n&nbsp;\n&nbsp;&nbsp;public&nbsp;boolean&nbsp;equals(Object&nbsp;obj)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!obj&nbsp;instanceof&nbsp;Person)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;other&nbsp;=&nbsp;(Person)obj;\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name.equals(other.name)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;birthYear&nbsp;==&nbsp;other.birthYear\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;Arrays.equals(raw,&nbsp;other.raw);\n&nbsp;&nbsp;}\n&nbsp;\n&nbsp;&nbsp;public&nbsp;int&nbsp;hashCode()&nbsp;{&nbsp;...&nbsp;}\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br/></span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参数必须是Object类型，不能是外围类。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">foo.equals(null) 必须返回false，不能抛NullPointerException。（注意，null instanceof 任意类 总是返回false，因此上面的代码可以运行。）</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">基本类型域（比如，int）的比较使用 == ，基本类型数组域的比较使用Arrays.equals()。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">覆盖equals()时，记得要相应地覆盖 hashCode()，与 equals() 保持一致。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考： java.lang.Object.equals(Object)。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\"><br/></span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">实现hashCode()</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">class&nbsp;Person&nbsp;{\n&nbsp;&nbsp;String&nbsp;a;\n&nbsp;&nbsp;Object&nbsp;b;\n&nbsp;&nbsp;byte&nbsp;c;\n&nbsp;&nbsp;int[]&nbsp;d;\n&nbsp;\n&nbsp;&nbsp;public&nbsp;int&nbsp;hashCode()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;a.hashCode()&nbsp;+&nbsp;b.hashCode()&nbsp;+&nbsp;c&nbsp;+&nbsp;Arrays.hashCode(d);\n&nbsp;&nbsp;}\n&nbsp;\n&nbsp;&nbsp;public&nbsp;boolean&nbsp;equals(Object&nbsp;o)&nbsp;{&nbsp;...&nbsp;}\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">当x和y两个对象具有x.equals(y) == true ，你必须要确保x.hashCode() == y.hashCode()。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">根据逆反命题，如果x.hashCode() != y.hashCode()，那么x.equals(y) == false 必定成立。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">你不需要保证，当x.equals(y) == false时，x.hashCode() != y.hashCode()。但是，如果你可以尽可能地使它成立的话，这会提高哈希表的性能。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">hashCode()最简单的合法实现就是简单地return 0；虽然这个实现是正确的，但是这会导致HashMap这些数据结构运行得很慢。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.lang.Object.hashCode()。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">实现compareTo()</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">class&nbsp;Person&nbsp;implements&nbsp;Comparable&lt;Person&gt;&nbsp;{\n&nbsp;&nbsp;String&nbsp;firstName;\n&nbsp;&nbsp;String&nbsp;lastName;\n&nbsp;&nbsp;int&nbsp;birthdate;\n&nbsp;\n&nbsp;&nbsp;//&nbsp;Compare&nbsp;by&nbsp;firstName,&nbsp;break&nbsp;ties&nbsp;by&nbsp;lastName,&nbsp;finally&nbsp;break&nbsp;ties&nbsp;by&nbsp;birthdate\n&nbsp;&nbsp;public&nbsp;int&nbsp;compareTo(Person&nbsp;other)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(firstName.compareTo(other.firstName)&nbsp;!=&nbsp;0)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;firstName.compareTo(other.firstName);\n&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(lastName.compareTo(other.lastName)&nbsp;!=&nbsp;0)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;lastName.compareTo(other.lastName);\n&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(birthdate&nbsp;&lt;&nbsp;other.birthdate)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;\n&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(birthdate&nbsp;&gt;&nbsp;other.birthdate)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;else\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;\n&nbsp;&nbsp;}\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">总是实现泛型版本 Comparable 而不是实现原始类型 Comparable 。因为这样可以节省代码量和减少不必要的麻烦。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">只关心返回结果的正负号（负/零/正），它们的大小不重要。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">Comparator.compare()的实现与这个类似。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.lang.Comparable。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">实现clone()</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">class&nbsp;Values&nbsp;implements&nbsp;Cloneable&nbsp;{\n&nbsp;&nbsp;String&nbsp;abc;\n&nbsp;&nbsp;double&nbsp;foo;\n&nbsp;&nbsp;int[]&nbsp;bars;\n&nbsp;&nbsp;Date&nbsp;hired;\n&nbsp;\n&nbsp;&nbsp;public&nbsp;Values&nbsp;clone()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Values&nbsp;result&nbsp;=&nbsp;(Values)super.clone();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.bars&nbsp;=&nbsp;result.bars.clone();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.hired&nbsp;=&nbsp;result.hired.clone();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(CloneNotSupportedException&nbsp;e)&nbsp;{&nbsp;&nbsp;//&nbsp;Impossible\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;AssertionError(e);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">使用 super.clone() 让Object类负责创建新的对象。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">基本类型域都已经被正确地复制了。同样，我们不需要去克隆String和BigInteger等不可变类型。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">手动对所有的非基本类型域（对象和数组）进行深度复制（deep copy）。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">实现了Cloneable的类，clone()方法永远不要抛CloneNotSupportedException。因此，需要捕获这个异常并忽略它，或者使用不受检异常（unchecked exception）包装它。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不使用Object.clone()方法而是手动地实现clone()方法是可以的也是合法的。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.lang.Object.clone()、java.lang.Cloneable()。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">使用StringBuilder或StringBuffer</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">//&nbsp;join([&quot;a&quot;,&nbsp;&quot;b&quot;,&nbsp;&quot;c&quot;])&nbsp;-&gt;&nbsp;&quot;a&nbsp;and&nbsp;b&nbsp;and&nbsp;c&quot;\nString&nbsp;join(List&lt;String&gt;&nbsp;strs)&nbsp;{\n&nbsp;&nbsp;StringBuilder&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuilder();\n&nbsp;&nbsp;boolean&nbsp;first&nbsp;=&nbsp;true;\n&nbsp;&nbsp;for&nbsp;(String&nbsp;s&nbsp;:&nbsp;strs)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(first)&nbsp;first&nbsp;=&nbsp;false;\n&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;sb.append(&quot;&nbsp;and&nbsp;&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;sb.append(s);\n&nbsp;&nbsp;}\n&nbsp;&nbsp;return&nbsp;sb.toString();\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不要像这样使用重复的字符串连接：s += item ，因为它的时间效率是O(n^2)。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">使用StringBuilder或者StringBuffer时，可以使用append()方法添加文本和使用toString()方法去获取连接起来的整个文本。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">优先使用StringBuilder，因为它更快。StringBuffer的所有方法都是同步的，而你通常不需要同步的方法。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考java.lang.StringBuilder、java.lang.StringBuffer。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">生成一个范围内的随机整数</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">Random&nbsp;rand&nbsp;=&nbsp;new&nbsp;Random();\n&nbsp;\n//&nbsp;Between&nbsp;1&nbsp;and&nbsp;6,&nbsp;inclusive\nint&nbsp;diceRoll()&nbsp;{\n&nbsp;&nbsp;return&nbsp;rand.nextInt(6)&nbsp;+&nbsp;1;\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">总是使用Java API方法去生成一个整数范围内的随机数。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不要试图去使用 Math.abs(rand.nextInt()) % n 这些不确定的用法，因为它的结果是有偏差的。此外，它的结果值有可能是负数，比如当rand.nextInt() == Integer.MIN_VALUE时就会如此。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.util.Random.nextInt(int)。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">使用Iterator.remove()</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">void&nbsp;filter(List&lt;String&gt;&nbsp;list)&nbsp;{\n&nbsp;&nbsp;for&nbsp;(Iterator&lt;String&gt;&nbsp;iter&nbsp;=&nbsp;list.iterator();&nbsp;iter.hasNext();&nbsp;)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;item&nbsp;=&nbsp;iter.next();\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(...)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iter.remove();\n&nbsp;&nbsp;}\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">remove()方法作用在next()方法最近返回的条目上。每个条目只能使用一次remove()方法。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.util.Iterator.remove()。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">返转字符串</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">String&nbsp;reverse(String&nbsp;s)&nbsp;{\n&nbsp;&nbsp;return&nbsp;new&nbsp;StringBuilder(s).reverse().toString();\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">这个方法可能应该加入Java标准库。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.lang.StringBuilder.reverse()。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">启动一条线程</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">下面的三个例子使用了不同的方式完成了同样的事情。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">实现Runnnable的方式：</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">void&nbsp;startAThread0()&nbsp;{\n&nbsp;&nbsp;new&nbsp;Thread(new&nbsp;MyRunnable()).start();\n}\n&nbsp;\nclass&nbsp;MyRunnable&nbsp;implements&nbsp;Runnable&nbsp;{\n&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;...\n&nbsp;&nbsp;}\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">继承Thread的方式：</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">void&nbsp;startAThread1()&nbsp;{\n&nbsp;&nbsp;new&nbsp;MyThread().start();\n}\n&nbsp;\nclass&nbsp;MyThread&nbsp;extends&nbsp;Thread&nbsp;{\n&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;...\n&nbsp;&nbsp;}\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">匿名继承Thread的方式：</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">void&nbsp;startAThread2()&nbsp;{\n&nbsp;&nbsp;new&nbsp;Thread()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}.start();\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不要直接调用run()方法。总是调用Thread.start()方法，这个方法会创建一条新的线程并使新建的线程调用run()。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.lang.Thread, java.lang.Runnable。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">使用try-finally</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">I/O流例子：</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">void&nbsp;writeStuff()&nbsp;throws&nbsp;IOException&nbsp;{\n&nbsp;&nbsp;OutputStream&nbsp;out&nbsp;=&nbsp;new&nbsp;FileOutputStream(...);\n&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;out.write(...);\n&nbsp;&nbsp;}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;out.close();\n&nbsp;&nbsp;}\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">锁例子：</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">void&nbsp;doWithLock(Lock&nbsp;lock)&nbsp;{\n&nbsp;&nbsp;lock.acquire();\n&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;...\n&nbsp;&nbsp;}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;lock.release();\n&nbsp;&nbsp;}\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">如果try之前的语句运行失败并且抛出异常，那么finally语句块就不会执行。但无论怎样，在这个例子里不用担心资源的释放。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">如果try语句块里面的语句抛出异常，那么程序的运行就会跳到finally语句块里执行尽可能多的语句，然后跳出这个方法（除非这个方法还有另一个外围的finally语句块）。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">从输入流里读取字节数据</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">InputStream&nbsp;in&nbsp;=&nbsp;(...);\ntry&nbsp;{\n&nbsp;&nbsp;while&nbsp;(true)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;b&nbsp;=&nbsp;in.read();\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(b&nbsp;==&nbsp;-1)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;(...&nbsp;process&nbsp;b&nbsp;...)\n&nbsp;&nbsp;}\n}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;in.close();\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">read()方法要么返回下一次从流里读取的字节数（0到255，包括0和255），要么在达到流的末端时返回-1。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.io.InputStream.read()。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">从输入流里读取块数据</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">InputStream&nbsp;in&nbsp;=&nbsp;(...);\ntry&nbsp;{\n&nbsp;&nbsp;byte[]&nbsp;buf&nbsp;=&nbsp;new&nbsp;byte[100];\n&nbsp;&nbsp;while&nbsp;(true)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;n&nbsp;=&nbsp;in.read(buf);\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;-1)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;(...&nbsp;process&nbsp;buf&nbsp;with&nbsp;offset=0&nbsp;and&nbsp;length=n&nbsp;...)\n&nbsp;&nbsp;}\n}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;in.close();\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">要记住的是，read()方法不一定会填满整个buf，所以你必须在处理逻辑中考虑返回的长度。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考： java.io.InputStream.read(byte[])、java.io.InputStream.read(byte[], int, int)。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">从文件里读取文本</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">BufferedReader&nbsp;in&nbsp;=&nbsp;new&nbsp;BufferedReader(\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;InputStreamReader(new&nbsp;FileInputStream(...),&nbsp;&quot;UTF-8&quot;));\ntry&nbsp;{\n&nbsp;&nbsp;while&nbsp;(true)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;line&nbsp;=&nbsp;in.readLine();\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(line&nbsp;==&nbsp;null)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;(...&nbsp;process&nbsp;line&nbsp;...)\n&nbsp;&nbsp;}\n}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;in.close();\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">BufferedReader对象的创建显得很冗长。这是因为Java把字节和字符当成两个不同的概念来看待（这与C语言不同）。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">你可以使用任何类型的InputStream来代替FileInputStream，比如socket。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">当达到流的末端时，BufferedReader.readLine()会返回null。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">要一次读取一个字符，使用Reader.read()方法。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">你可以使用其他的字符编码而不使用UTF-8，但最好不要这样做。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.io.BufferedReader、java.io.InputStreamReader。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">向文件里写文本</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">PrintWriter&nbsp;out&nbsp;=&nbsp;new&nbsp;PrintWriter(\n&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;OutputStreamWriter(new&nbsp;FileOutputStream(...),&nbsp;&quot;UTF-8&quot;));\ntry&nbsp;{\n&nbsp;&nbsp;out.print(&quot;Hello&nbsp;&quot;);\n&nbsp;&nbsp;out.print(42);\n&nbsp;&nbsp;out.println(&quot;&nbsp;world!&quot;);\n}&nbsp;finally&nbsp;{\n&nbsp;&nbsp;out.close();\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">Printwriter对象的创建显得很冗长。这是因为Java把字节和字符当成两个不同的概念来看待（这与C语言不同）。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">就像System.out，你可以使用print()和println()打印多种类型的值。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">你可以使用其他的字符编码而不使用UTF-8，但最好不要这样做。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.io.PrintWriter、java.io.OutputStreamWriter。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">预防性检测（Defensive checking）数值</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">int&nbsp;factorial(int&nbsp;n)&nbsp;{\n&nbsp;&nbsp;if&nbsp;(n&nbsp;&lt;&nbsp;0)\n&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException(&quot;Undefined&quot;);\n&nbsp;&nbsp;else&nbsp;if&nbsp;(n&nbsp;&gt;=&nbsp;13)\n&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;ArithmeticException(&quot;Result&nbsp;overflow&quot;);\n&nbsp;&nbsp;else&nbsp;if&nbsp;(n&nbsp;==&nbsp;0)\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;\n&nbsp;&nbsp;else\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;n&nbsp;*&nbsp;factorial(n&nbsp;-&nbsp;1);\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不要认为输入的数值都是正数、足够小的数等等。要显式地检测这些条件。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">一个设计良好的函数应该对所有可能性的输入值都能够正确地执行。要确保所有的情况都考虑到了并且不会产生错误的输出（比如溢出）。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">预防性检测对象</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">int&nbsp;findIndex(List&lt;String&gt;&nbsp;list,&nbsp;String&nbsp;target)&nbsp;{\n&nbsp;&nbsp;if&nbsp;(list&nbsp;==&nbsp;null&nbsp;||&nbsp;target&nbsp;==&nbsp;null)\n&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;NullPointerException();\n&nbsp;&nbsp;...\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不要认为对象参数不会为空（null）。要显式地检测这个条件。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">预防性检测数组索引</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">void&nbsp;frob(byte[]&nbsp;b,&nbsp;int&nbsp;index)&nbsp;{\n&nbsp;&nbsp;if&nbsp;(b&nbsp;==&nbsp;null)\n&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;NullPointerException();\n&nbsp;&nbsp;if&nbsp;(index&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;index&nbsp;&gt;=&nbsp;b.length)\n&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IndexOutOfBoundsException();\n&nbsp;&nbsp;...\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不要认为所以给的数组索引不会越界。要显式地检测它。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">预防性检测数组区间</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">void&nbsp;frob(byte[]&nbsp;b,&nbsp;int&nbsp;off,&nbsp;int&nbsp;len)&nbsp;{\n&nbsp;&nbsp;if&nbsp;(b&nbsp;==&nbsp;null)\n&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;NullPointerException();\n&nbsp;&nbsp;if&nbsp;(off&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;off&nbsp;&gt;&nbsp;b.length\n&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;len&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;b.length&nbsp;-&nbsp;off&nbsp;&lt;&nbsp;len)\n&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IndexOutOfBoundsException();\n&nbsp;&nbsp;...\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不要认为所给的数组区间（比如，从off开始，读取len个元素）是不会越界。要显式地检测它。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">填充数组元素</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">使用循环：</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">//&nbsp;Fill&nbsp;each&nbsp;element&nbsp;of&nbsp;array&nbsp;&#39;a&#39;&nbsp;with&nbsp;123\nbyte[]&nbsp;a&nbsp;=&nbsp;(...);\nfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;a.length;&nbsp;i++)\n&nbsp;&nbsp;a[i]&nbsp;=&nbsp;123;</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">（优先）使用标准库的方法：</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">Arrays.fill(a, (byte)123);</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.util.Arrays.fill(T[], T)。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.util.Arrays.fill(T[], int, int, T)。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">复制一个范围内的数组元素</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">使用循环：</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">//&nbsp;Copy&nbsp;8&nbsp;elements&nbsp;from&nbsp;array&nbsp;&#39;a&#39;&nbsp;starting&nbsp;at&nbsp;offset&nbsp;3\n//&nbsp;to&nbsp;array&nbsp;&#39;b&#39;&nbsp;starting&nbsp;at&nbsp;offset&nbsp;6,\n//&nbsp;assuming&nbsp;&#39;a&#39;&nbsp;and&nbsp;&#39;b&#39;&nbsp;are&nbsp;distinct&nbsp;arrays\nbyte[]&nbsp;a&nbsp;=&nbsp;(...);\nbyte[]&nbsp;b&nbsp;=&nbsp;(...);\nfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;8;&nbsp;i++)\n&nbsp;&nbsp;b[6&nbsp;+&nbsp;i]&nbsp;=&nbsp;a[3&nbsp;+&nbsp;i];</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">（优先）使用标准库的方法：</span></p><pre class=\"brush:java;toolbar:false\">System.arraycopy(a,&nbsp;3,&nbsp;b,&nbsp;6,&nbsp;8);</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.lang.System.arraycopy(Object, int, Object, int, int)。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">调整数组大小</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">使用循环（扩大规模）：</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">//&nbsp;Make&nbsp;array&nbsp;&#39;a&#39;&nbsp;larger&nbsp;to&nbsp;newLen\nbyte[]&nbsp;a&nbsp;=&nbsp;(...);\nbyte[]&nbsp;b&nbsp;=&nbsp;new&nbsp;byte[newLen];\nfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;a.length;&nbsp;i++)&nbsp;&nbsp;//&nbsp;Goes&nbsp;up&nbsp;to&nbsp;length&nbsp;of&nbsp;A\n&nbsp;&nbsp;b[i]&nbsp;=&nbsp;a[i];\na&nbsp;=&nbsp;b;</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">使用循环（减小规模）：</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">//&nbsp;Make&nbsp;array&nbsp;&#39;a&#39;&nbsp;smaller&nbsp;to&nbsp;newLen\nbyte[]&nbsp;a&nbsp;=&nbsp;(...);\nbyte[]&nbsp;b&nbsp;=&nbsp;new&nbsp;byte[newLen];\nfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;b.length;&nbsp;i++)&nbsp;&nbsp;//&nbsp;Goes&nbsp;up&nbsp;to&nbsp;length&nbsp;of&nbsp;B\n&nbsp;&nbsp;b[i]&nbsp;=&nbsp;a[i];\na&nbsp;=&nbsp;b;</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">（优先）使用标准库的方法：</span></p><pre class=\"brush:java;toolbar:false\">a&nbsp;=&nbsp;Arrays.copyOf(a,&nbsp;newLen);</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.util.Arrays.copyOf(T[], int)。</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">参考：java.util.Arrays.copyOfRange(T[], int, int)。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">把4个字节包装（packing）成一个int</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">int&nbsp;packBigEndian(byte[]&nbsp;b)&nbsp;{\n&nbsp;&nbsp;return&nbsp;(b[0]&nbsp;&amp;&nbsp;0xFF)&nbsp;&lt;&lt;&nbsp;24\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(b[1]&nbsp;&amp;&nbsp;0xFF)&nbsp;&lt;&lt;&nbsp;16\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(b[2]&nbsp;&amp;&nbsp;0xFF)&nbsp;&lt;&lt;&nbsp;&nbsp;8\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(b[3]&nbsp;&amp;&nbsp;0xFF)&nbsp;&lt;&lt;&nbsp;&nbsp;0;\n}\n&nbsp;\nint&nbsp;packLittleEndian(byte[]&nbsp;b)&nbsp;{\n&nbsp;&nbsp;return&nbsp;(b[0]&nbsp;&amp;&nbsp;0xFF)&nbsp;&lt;&lt;&nbsp;&nbsp;0\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(b[1]&nbsp;&amp;&nbsp;0xFF)&nbsp;&lt;&lt;&nbsp;&nbsp;8\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(b[2]&nbsp;&amp;&nbsp;0xFF)&nbsp;&lt;&lt;&nbsp;16\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;(b[3]&nbsp;&amp;&nbsp;0xFF)&nbsp;&lt;&lt;&nbsp;24;\n}</pre><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">把int分解（Unpacking）成4个字节</span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span></p><pre class=\"brush:java;toolbar:false\">byte[]&nbsp;unpackBigEndian(int&nbsp;x)&nbsp;{\n&nbsp;&nbsp;return&nbsp;new&nbsp;byte[]&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;(byte)(x&nbsp;&gt;&gt;&gt;&nbsp;24),\n&nbsp;&nbsp;&nbsp;&nbsp;(byte)(x&nbsp;&gt;&gt;&gt;&nbsp;16),\n&nbsp;&nbsp;&nbsp;&nbsp;(byte)(x&nbsp;&gt;&gt;&gt;&nbsp;&nbsp;8),\n&nbsp;&nbsp;&nbsp;&nbsp;(byte)(x&nbsp;&gt;&gt;&gt;&nbsp;&nbsp;0)\n&nbsp;&nbsp;};\n}\n&nbsp;\nbyte[]&nbsp;unpackLittleEndian(int&nbsp;x)&nbsp;{\n&nbsp;&nbsp;return&nbsp;new&nbsp;byte[]&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;(byte)(x&nbsp;&gt;&gt;&gt;&nbsp;&nbsp;0),\n&nbsp;&nbsp;&nbsp;&nbsp;(byte)(x&nbsp;&gt;&gt;&gt;&nbsp;&nbsp;8),\n&nbsp;&nbsp;&nbsp;&nbsp;(byte)(x&nbsp;&gt;&gt;&gt;&nbsp;16),\n&nbsp;&nbsp;&nbsp;&nbsp;(byte)(x&nbsp;&gt;&gt;&gt;&nbsp;24)\n&nbsp;&nbsp;};\n}</pre><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"></span><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">总是使用无符号右移操作符（&gt;&gt;&gt;）对位进行包装（packing），不要使用算术右移操作符（&gt;&gt;）。</span></p><p style=\"white-space: normal;\"><br/></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 12px;\">原文：<a href=\"http://www.nayuki.io/page/good-java-idioms\" target=\"_blank\" title=\"http://www.nayuki.io/page/good-java-idioms\">http://www.nayuki.io/page/good-java-idioms</a></span></p><p style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 12px;\">转自：<a href=\"http://www.importnew.com/15605.html\" target=\"_blank\" title=\"http://www.importnew.com/15605.html\">http://www.importnew.com/15605.html</a></span></p><p><br/></p>','Ken','1453645666821','Ken','1453645666821'),(8,'Two Sum',2,'LeetCode: 1 Two Sum','<p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; white-space: normal; background-color: rgb(255, 255, 255);\">Given an array of integers, find two numbers such that they add up to a specific target number.<br/></p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; white-space: normal; background-color: rgb(255, 255, 255);\">The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; white-space: normal; background-color: rgb(255, 255, 255);\">You may assume that each input would have exactly one solution.</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-size: 14px; line-height: 30px; white-space: normal; font-family: monospace; background-color: rgb(255, 255, 255);\"><span style=\"box-sizing: border-box; font-weight: 700;\">Input:</span>&nbsp;numbers={2, 7, 11, 15}, target=9<br style=\"box-sizing: border-box;\"/><span style=\"box-sizing: border-box; font-weight: 700;\">Output:</span>&nbsp;index1=1, index2=2</p><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">解题思路：</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">暴力循环~</span></p><p><br/></p><p><span style=\"font-size: 22px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Java代码：<a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/q/leetcode/TwoSum.java\" target=\"_blank\" title=\"Two Sum\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">源代码</span></a></span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;int[]&nbsp;twoSum(int[]&nbsp;nums,&nbsp;int&nbsp;target)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int[]&nbsp;result&nbsp;=&nbsp;new&nbsp;int[2];\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;i&nbsp;+&nbsp;1;&nbsp;j&nbsp;&lt;&nbsp;nums.length;&nbsp;j++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(nums[i]&nbsp;+&nbsp;nums[j]&nbsp;==&nbsp;target)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[0]&nbsp;=&nbsp;i&nbsp;+&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[1]&nbsp;=&nbsp;j&nbsp;+&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n}</pre><p><br/></p><p><a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" title=\"Two Sum\" style=\"line-height: 30px; white-space: normal; text-decoration: underline; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">题目链接</span></a></p>','Ken','1453713422238','Ken','1453713422238'),(9,'Single Number',2,'LeetCode: 136. Single Number','<p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; white-space: normal; background-color: rgb(255, 255, 255);\">Given an array of integers, every element appears&nbsp;<em style=\"box-sizing: border-box;\">twice</em>&nbsp;except for one. Find that single one.</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"box-sizing: border-box; font-weight: 700;\">Note:</span><br style=\"box-sizing: border-box;\"/>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">解题思路：</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">根据对两个相同的值进行异或运算结果为0的特点，将数组所有值进行异或运算， 结果就是单独出来的数字。</span></p><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">Java代码：</span><a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/q/leetcode/SingleNumber.java\" target=\"_blank\" title=\"Single Number\"><span style=\"font-size: 14px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">源代码</span></a><br/></p><pre class=\"brush:java;toolbar:false\">public&nbsp;int&nbsp;singleNumber(int[]&nbsp;nums)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;nums[0];\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;nums.length;&nbsp;i++)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;^=&nbsp;nums[i];\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n}</pre><p><br/></p><p><a href=\"https://leetcode.com/problems/single-number/\" target=\"_blank\" title=\"Single Number\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">题目链接</span></a><br/></p>','Ken','1453731608382','Ken','1453731608382'),(10,'快速排序',1,'快速排序是对冒泡排序的一种改进，使用分治法策略来把一个序列分成两个子序列。','<p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">基本思想：</span><br/></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">通过一趟排序将记录划分成为独立的两个部分，其中一部分记录的关键字均不大于另一部分记录的关键字，然后再分别对这两部分记录进行快速排序。</span></p><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">Java代码实现：</span><a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/algomrithm/Quick.java\" target=\"_blank\" title=\"快速排序\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">源代码</span></a></p><pre class=\"brush:java;toolbar:false\">private&nbsp;static&nbsp;&lt;T&gt;&nbsp;void&nbsp;sort(Comparable&lt;T&gt;[]&nbsp;a,&nbsp;int&nbsp;low,&nbsp;int&nbsp;right)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;low;\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j&nbsp;=&nbsp;right;\n&nbsp;&nbsp;&nbsp;&nbsp;Comparable&lt;T&gt;&nbsp;p&nbsp;=&nbsp;a[low];\n&nbsp;&nbsp;&nbsp;&nbsp;while(i&nbsp;&lt;&nbsp;j)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(i&nbsp;&lt;&nbsp;j&nbsp;&amp;&amp;&nbsp;less(p,&nbsp;a[j]))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j--;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i&nbsp;&lt;&nbsp;j)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exch(a,&nbsp;i++,&nbsp;j);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(i&nbsp;&lt;&nbsp;j&nbsp;&amp;&amp;&nbsp;less(a[i],&nbsp;p))&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(i&nbsp;&lt;&nbsp;j)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exch(a,&nbsp;i,&nbsp;j--);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;if(i&nbsp;&gt;&nbsp;low)&nbsp;sort(a,&nbsp;low,&nbsp;i&nbsp;-&nbsp;1);\n&nbsp;&nbsp;&nbsp;&nbsp;if(j&nbsp;&lt;&nbsp;right)&nbsp;sort(a,&nbsp;i&nbsp;+&nbsp;1,&nbsp;right);\n}</pre><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">算法分析：</span><br/></p><table data-sort=\"sortDisabled\" width=\"-306\"><tbody><tr class=\"firstRow\"><td valign=\"top\" rowspan=\"1\" colspan=\"3\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">时间复杂度</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong><br/></strong></span></td><td width=\"132\" valign=\"top\" rowspan=\"2\" colspan=\"1\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">空间复杂度</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong><br/></strong></span></td><td width=\"132\" valign=\"top\" rowspan=\"2\" colspan=\"1\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">稳定性<strong><br/></strong></span></td></tr><tr><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">平均情况</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最坏情况</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最好情况</span></td></tr><tr><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(nlogn)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n<sup>2</sup>)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(nlogn)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(logn)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不稳定</span></td></tr></tbody></table><p><br/></p>','Ken','1453734143679','Ken','1453734143679'),(11,'冒泡排序',1,'重复的走访待排序的数列，一次比较两个元素，如果它们顺序错误就把它们交换过来。冒泡排序只适合元素较少的数列排列。','<p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">算法描述：</span><br/></p><ol style=\"margin-top: 0.3em; margin-left: 3.2em; padding: 0px; list-style-image: none; color: rgb(37, 37, 37); font-size: 14px; line-height: 22.4px; white-space: normal; background-color: rgb(255, 255, 255);\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">比较相邻的元素。如果第一个比第二个大，就交换他们两个。</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">针对所有的元素重复以上的步骤，除了最后一个。</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span></p></li></ol><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">Java代码实现：</span><a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/algomrithm/Bubble.java\" target=\"_blank\" title=\"冒泡排序\"><span style=\"font-size: 14px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">源代码</span></a><br/></p><pre class=\"brush:java;toolbar:false\">public&nbsp;static&nbsp;&lt;T&gt;&nbsp;void&nbsp;sort(Comparable&lt;T&gt;[]&nbsp;a)&nbsp;{\n\tint&nbsp;n&nbsp;=&nbsp;a.length;\n\tfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{\n\t\tfor&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;n&nbsp;-&nbsp;i&nbsp;-&nbsp;1;&nbsp;j++)&nbsp;{\n\t\t\tif(less(a[j&nbsp;+&nbsp;1],&nbsp;a[j]))&nbsp;{\n\t\t\t\texch(a,&nbsp;j,&nbsp;j&nbsp;+&nbsp;1);\n\t\t\t}\n\t\t}\n\t}\n}</pre><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">算法分析：</span><br/></p><table data-sort=\"sortDisabled\" width=\"-306\"><tbody><tr class=\"firstRow\"><td valign=\"top\" rowspan=\"1\" colspan=\"3\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">时间复杂度</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong><br/></strong></span></td><td width=\"132\" valign=\"top\" rowspan=\"2\" colspan=\"1\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">空间复杂度</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong><br/></strong></span></td><td width=\"132\" valign=\"top\" rowspan=\"2\" colspan=\"1\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">稳定性<strong><br/></strong></span></td></tr><tr><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">平均情况</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最坏情况</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最好情况</span></td></tr><tr><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n<sup>2</sup>)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n<span style=\"position: relative; font-size: 12px; line-height: 0; vertical-align: baseline; top: -0.5em;\">2</span>)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(1)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">稳定</span></td></tr></tbody></table>','Ken','1453779227740','Ken','1453779227740'),(12,'Add Two Numbers',2,'LeetCode: 2. Add Two Numbers','<p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; white-space: normal; background-color: rgb(255, 255, 255);\">You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-size: 14px; line-height: 30px; white-space: normal; font-family: monospace; background-color: rgb(255, 255, 255);\"><span style=\"box-sizing: border-box; font-weight: 700;\">Input:</span>&nbsp;(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br style=\"box-sizing: border-box;\"/><span style=\"box-sizing: border-box; font-weight: 700;\">Output:</span>&nbsp;7 -&gt; 0 -&gt; 8</p><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">解题思路：</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">建一个新链表，把输入的两个链表从头往后每两个数字相加然后放入新链表中。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">要注意的是相加的进位要累加到下一个节点的两个数相加。遍历计算之后如果存在进位，要注意处理。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最后，返回的不是链表的最后一个节点。<br/></span></p><p><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">Java代码：</span><a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/q/leetcode/AddTwoNumbers.java\" target=\"_blank\" title=\"Add Two Numbers\" style=\"text-decoration: underline; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">源代码</span></a><br/></p><pre class=\"brush:java;toolbar:false\">public&nbsp;ListNode&nbsp;addTwoNumbers(ListNode&nbsp;l1,&nbsp;ListNode&nbsp;l2)&nbsp;{\n\tint&nbsp;carry&nbsp;=&nbsp;0;\n\tListNode&nbsp;newP&nbsp;=&nbsp;new&nbsp;ListNode(0);\n\tListNode&nbsp;resultP&nbsp;=&nbsp;newP;\n\twhile(l1&nbsp;!=&nbsp;null&nbsp;||&nbsp;l2&nbsp;!=&nbsp;null)&nbsp;{\n\t\tif(l1&nbsp;!=&nbsp;null)&nbsp;{\n\t\t\tcarry&nbsp;+=&nbsp;l1.val;\n\t\t\tl1&nbsp;=&nbsp;l1.next;\n\t\t}\n\t\tif(l2&nbsp;!=&nbsp;null)&nbsp;{\n\t\t\tcarry&nbsp;+=&nbsp;l2.val;\n\t\t\tl2&nbsp;=&nbsp;l2.next;\n\t\t}\n\t\t\n\t\tnewP.next&nbsp;=&nbsp;new&nbsp;ListNode(carry&nbsp;%&nbsp;10);\n\t\tnewP&nbsp;=&nbsp;newP.next;\n\t\tcarry&nbsp;/=&nbsp;10;\n\t}\n\t\n\tif(carry&nbsp;==&nbsp;1)&nbsp;{\n\t\tnewP.next&nbsp;=&nbsp;new&nbsp;ListNode(1);\n\t}\n\t\n\treturn&nbsp;resultP.next;\n}</pre><p><br/></p><p><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" title=\"Add Two Numbers\" style=\"text-decoration: underline; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">题目链接</span></a></p>','Ken','1453795592049','Ken','1453795592049'),(13,'Longest Substring Without Repeating Characters',2,'LeetCode: 3. Longest Substring Without Repeating Characters','<p><span style=\"color: rgb(51, 51, 51); font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; background-color: rgb(255, 255, 255);\"><span style=\"color: rgb(51, 51, 51); font-family: &#39;Helvetica Neue&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 30px; background-color: rgb(255, 255, 255);\">Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for &quot;abcabcbb&quot; is &quot;abc&quot;, which the length is 3. For &quot;bbbbb&quot; the longest substring is &quot;b&quot;, with the length of 1.</span></span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">解题思路：</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">使用一个变量max表示最长无重复子串的长度，一个变量begin指向无重复子串的起始位置，使用一个HashMap记录已经访问过的不重复的字符。遍历字符串，判断Map里面有没有已经存在的字符，不存在则计算max的值，存在则begin后移一位，清空Map，从begin后一位继续遍历。</span><br/></p><p><strong><br/></strong></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">Java代码：</span><a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/q/leetcode/LongestSubstringWithoutRepeatingCharacters.java\" target=\"_blank\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">源代码</span></a><strong><br/></strong></p><pre class=\"brush:java;toolbar:false\">public&nbsp;static&nbsp;int&nbsp;lengthOfLongestSubstring(String&nbsp;s)&nbsp;{\n\tif(s&nbsp;==&nbsp;null)&nbsp;{\n\t\treturn&nbsp;0;\n\t}\n\tif(s.length()&nbsp;&lt;&nbsp;2)&nbsp;{\n\t\treturn&nbsp;s.length();\n\t}\n\tchar[]&nbsp;c&nbsp;=&nbsp;s.toCharArray();\n\tMap&lt;Character,&nbsp;Character&gt;&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap&lt;Character,&nbsp;Character&gt;();\n\tmap.put(c[0],&nbsp;c[0]);\n\tint&nbsp;max&nbsp;=&nbsp;1;\n\tint&nbsp;begin&nbsp;=&nbsp;0;\n\tfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;c.length;&nbsp;)&nbsp;{\n\t\tif(map.get(c[i])&nbsp;==&nbsp;null)&nbsp;{\n\t\t\tif(max&nbsp;&lt;&nbsp;i&nbsp;-&nbsp;begin&nbsp;+&nbsp;1)&nbsp;{\n\t\t\t\tmax&nbsp;=&nbsp;i&nbsp;-&nbsp;begin&nbsp;+&nbsp;1;\n\t\t\t}\n\t\t\tmap.put(c[i],&nbsp;c[i]);\n\t\t\ti++;\n\t\t}else&nbsp;{\n\t\t\tbegin&nbsp;+=&nbsp;1;\n\t\t\ti&nbsp;=&nbsp;begin&nbsp;+&nbsp;1;\n\t\t\tmap.clear();\n\t\t\tmap.put(c[begin],&nbsp;c[begin]);\n\t\t}\n\t}\n\treturn&nbsp;max;\n}</pre><p><br/></p><p><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" title=\"3. Longest Substring Without Repeating Characters\"><span style=\"font-size: 14px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">题目链接</span></a></p>','Ken','1453894324194','Ken','1453894324194'),(14,'直接插入排序',1,'插入排序的工作原理是对已排序序列从后往前扫描，找到合适位置插入未排序的元素。','<p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">算法描述：</span></p><ol style=\"margin-top: 0.3em; margin-left: 3.2em; padding: 0px; list-style-image: none; color: rgb(37, 37, 37); font-size: 14px; line-height: 22.4px; white-space: normal; background-color: rgb(255, 255, 255);\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">从第一个元素开始，该元素可以认为已经被排序</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">取出下一个元素，在已经排序的元素序列中从后向前扫描</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">如果该元素（已排序）大于新元素，将该元素移到下一位置</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">将新元素插入到该位置后</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">重复步骤2~5</span></p></li></ol><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"></span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">Java代码实现：</span><a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/algomrithm/Insertion.java\" target=\"_blank\" title=\"插入排序\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">源代码</span></a><br/></p><pre class=\"brush:java;toolbar:false\">public&nbsp;static&nbsp;&lt;T&gt;&nbsp;void&nbsp;sort(Comparable&lt;T&gt;[]&nbsp;a)&nbsp;{\n\tint&nbsp;n&nbsp;=&nbsp;a.length;\n\tfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;1;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{\n\t\tfor&nbsp;(int&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;less(a[j],&nbsp;a[j&nbsp;-&nbsp;1])&nbsp;;&nbsp;j--)&nbsp;{\n\t\t\texch(a,&nbsp;j,&nbsp;j&nbsp;-&nbsp;1);\n\t\t}\n\t}\n}</pre><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">算法分析：</span><br/></p><table data-sort=\"sortDisabled\" width=\"-306\"><tbody><tr class=\"firstRow\"><td valign=\"top\" rowspan=\"1\" colspan=\"3\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">时间复杂度</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong><br/></strong></span></td><td width=\"132\" valign=\"top\" rowspan=\"2\" colspan=\"1\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">空间复杂度</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><strong><br/></strong></span></td><td width=\"132\" valign=\"top\" rowspan=\"2\" colspan=\"1\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">稳定性<strong><br/></strong></span></td></tr><tr><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">平均情况</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最坏情况</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最好情况</span></td></tr><tr><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n<sup>2</sup>)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n<span style=\"position: relative; font-size: 12px; line-height: 0; vertical-align: baseline; top: -0.5em;\">2</span>)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(n<sup>2</sup>)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">O(1)</span></td><td width=\"132\" valign=\"top\" style=\"word-break: break-all; text-align: center;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">稳定<br/><br/></span></td></tr></tbody></table><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">1.直接插入排序<span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(37, 37, 37); line-height: 22.4px; background-color: rgb(255, 255, 255);\">不适合对于数据量比较大的排序应用</span></span></p>','Ken','1453899923997','Ken','1453899923997'),(15,'希尔排序',1,'又称“缩小增量排序”，它是对直接插入排序方法的优化版本。','<p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">算法描述：</span><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">基本思想是先将整个序列分割成若干子序列，然后分别进行直接插入排序，然后再重复刚才的步骤，直到所有元素都在同一序列进行直接插入排序为止。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">具体做法：<br/></span></p><ol class=\" list-paddingleft-2\" style=\"list-style-type: decimal;\"><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">取一个小于n的整数d<sub>1</sub>作为第一个增量（通常取序列的一半为增量，以后每次减半），把序列元素分成d<sub>1</sub>组，即将所有距离为d<sub>1</sub>倍数序号的元素放在同一个组中，在各组内进行直接插入排序；</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">取第二个增量d<sub><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 13.3333px;\">2</span></sub><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 13.3333px;\">（d<sub style=\"white-space: normal;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 13.3333px;\">2 </span></sub><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 13.3333px;\">&lt; d<sub>1</sub></span>），重复上述分组和排序工作，直到增量d<sub>i</sub>=1（此时序列所有元素应该在同一组内）。</span></span></p></li></ol><p><br/></p><p><span style=\"font-size: 22px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Java代码实现：</span><span style=\"font-size: 16px;\"><a href=\"https://github.com/KenKwan/question/blob/master/src/main/java/org/bedoing/algomrithm/Shell.java\" target=\"_blank\" style=\"text-decoration: underline; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 14px;\">源代码</span></a></span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;static&nbsp;&lt;T&gt;&nbsp;void&nbsp;sort(Comparable&lt;T&gt;[]&nbsp;a)&nbsp;{\n\tint&nbsp;n&nbsp;=&nbsp;a.length;\n\tint&nbsp;h&nbsp;=&nbsp;1;\n\twhile(h&nbsp;&lt;&nbsp;n/3)&nbsp;{\n\t\th&nbsp;=&nbsp;3&nbsp;*&nbsp;h&nbsp;+&nbsp;1;\n\t}\n\t\n\tfor&nbsp;(;&nbsp;h&nbsp;&gt;=&nbsp;1;&nbsp;h&nbsp;=&nbsp;h/3)&nbsp;{\n\t\tfor&nbsp;(int&nbsp;i&nbsp;=&nbsp;h;&nbsp;i&nbsp;&lt;&nbsp;n;&nbsp;i++)&nbsp;{\n\t\t\tfor&nbsp;(int&nbsp;j&nbsp;=&nbsp;i;&nbsp;j&nbsp;&gt;=&nbsp;h&nbsp;&amp;&amp;&nbsp;less(a[j],&nbsp;a[j&nbsp;-&nbsp;h]);&nbsp;j&nbsp;-=&nbsp;h)&nbsp;{\n\t\t\t\texch(a,&nbsp;j,&nbsp;j&nbsp;-&nbsp;h);\n\t\t\t}\n\t\t}\n\t}\n}</pre><p><span style=\"font-size: 16px;\"></span><br/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">算法分析：</span></p><ol class=\" list-paddingleft-2\" style=\"list-style-type: decimal;\"><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">希尔排序是直接插入排序算法的一种更高效的改进版本。</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">希尔排序是一种不稳定的排序方法，其时间复杂度约为（O(n<sup>1.3</sup>)）,排序过程中只需要一个元素的辅助空间，所以其空间复杂度为O(1)；</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">适合中等大小数据规模，在最坏的情况下和平均情况下执行效率相差不是很多，而快速排序在最坏的情况下执行的效率会非常差；</span></p></li><li><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">不同增量的选择会影响排序的效率。</span><br/></p></li></ol><br/><p><br/></p>','Ken','1453901733230','Ken','1453901733230');
INSERT INTO `article` VALUES (18,'Java面试基础之Java基础知识（上）',1,'String、StringBuffer，StringBuilder之间区别: \n    1. String是final类，任何对String的改变都会生成新的字符串对象，而StringBuffer和StringBuilder是可改变类，修改它们不会产生新的对象。\n    2. StringBuffer是线程安全，StringBuilder非线程安全，所以单线程中使用StringBuilder效率会较高。','<div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 26px; color: rgb(0, 112, 192);\">一&nbsp;字符串相关(String)</span></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">1.1 String、StringBuffer，StringBuilder之间区别</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;1.&nbsp;String是final类，任何对String的改变都会生成新的字符串对象，而StringBuffer和StringBuilder是可改变类，修改它们不会产生新的对象。</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;2.&nbsp;StringBuffer是线程安全，StringBuilder非线程安全，所以单线程中使用StringBuilder效率会较高。</span></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">1.2&nbsp;String是最基本的数据类型吗?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;基本数据类型包括byte、int、char、long、float、double、boolean和short。&nbsp;java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">1.3 String&nbsp;s&nbsp;=&nbsp;new&nbsp;String(&quot;xyz&quot;);创建了几个String&nbsp;Object?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。New&nbsp;String每写一遍，就创建一个新的对象，它依据那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过’xyz’，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">1.4 是否可以继承String类?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;String类是final类故不可以继承。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">1.5 我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种编码的字符串？&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Public&nbsp;String&nbsp;translate&nbsp;(String&nbsp;str)&nbsp;{&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">String&nbsp;tempStr&nbsp;=&nbsp;&quot;&quot;;&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">try&nbsp;{&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">tempStr&nbsp;=&nbsp;new&nbsp;String(str.getBytes(&quot;ISO-8859-1&quot;),&nbsp;&quot;GBK&quot;);&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">tempStr&nbsp;=&nbsp;tempStr.trim();&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">}&nbsp;</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">System.err.println(e.getMessage());&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">}&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">return&nbsp;tempStr;&nbsp;</span></div><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">}&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">1.6 下面这条语句一共创建了多少个对象：String&nbsp;s=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果，所有创建了一个对象</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">1.7 java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;字节流，字符流。字节流继承于InputStream&nbsp;OutputStream，字符流继承于InputStreamReader&nbsp;OutputStreamWriter。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">1.8 字节流与字符流的区别</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream&nbsp;，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">其实是转成该字符的某种编码的字节形式，读取也是反之的道理。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">1.9 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">我们有时候将一个java对象变成字节流的形式传出去或者从一个字节流中恢复成一个java对象，例如，要将java对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个java对象变成某个格式的字节流再传输，但是，jre本身就提供了这种支持，我们可以调用OutputStream的writeObject方法来做，如果要让java&nbsp;帮我们做，要被传输的对象必须实现serializable接口，这样，javac编译时就会进行特殊处理，编译的类才可以被writeObject方法操作，这就是所谓的序列化。需要被序列化的类必须实现Serializable接口，该接口是一个mini接口，其中没有需要实现的方法，implements&nbsp;Serializable只是为了标注该对象是可被序列化的。&nbsp;</span></p><p><br style=\"background-color: inherit;\"/></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 26px; color: rgb(0, 112, 192);\">二&nbsp;异常相关(Exception)</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">2.1 运行时异常与一般异常有何异同？</span><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">2.2 error和exception有什么区别?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;exception&nbsp;表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">2.3 什么时候用assert。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">2.4 给我一个你最常见到的runtime&nbsp;exception。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;ArithmeticException,&nbsp;ArrayStoreException,&nbsp;BufferOverflowException,&nbsp;BufferUnderflowException,&nbsp;CannotRedoException,&nbsp;CannotUndoException,&nbsp;ClassCastException,&nbsp;CMMException,&nbsp;ConcurrentModificationException,&nbsp;DOMException,&nbsp;EmptyStackException,&nbsp;IllegalArgumentException,&nbsp;IllegalMonitorStateException,&nbsp;IllegalPathStateException,&nbsp;IllegalStateException,&nbsp;ImagingOpException,&nbsp;IndexOutOfBoundsException,&nbsp;MissingResourceException,&nbsp;NegativeArraySizeException,&nbsp;NoSuchElementException,&nbsp;NullPointerException,&nbsp;ProfileDataException,&nbsp;ProviderException,&nbsp;RasterFormatException,&nbsp;SecurityException,&nbsp;SystemException,&nbsp;UndeclaredThrowableException,&nbsp;UnmodifiableSetException,&nbsp;UnsupportedOperationException</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">2.5 try&nbsp;{}里有一个return语句，那么紧跟在这个try后的finally&nbsp;{}里的code会不会被执行，什么时候被执行，在return前还是后?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">会执行，在return前执行。</span></p><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">static&nbsp;int&nbsp;test()&nbsp;{</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;1;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;x;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;finally&nbsp;{</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++x;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp; }&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">结果返回1.</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">2.6 Java中的异常处理机制的简单原理和应用。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;当JAVA程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是java.lang.Thowable的子类。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error&nbsp;表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">2.7&nbsp;JAVA语言如何进行异常处理关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;可以，一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用try来指定一块预防所有“异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的“异常”的类型。throw语句用来明确地抛出一个“异常”。throws用来标明一个成员函数可能抛出的各种“异常”。Finally为确保一段代码不管发生什么“异常”都被执行一段代码。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">2.8 垃圾回收的优点和原理。并考虑2种回收机制。&nbsp;</span><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</span></p><div><br style=\"background-color: inherit;\"/></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 26px;\">三&nbsp;反射相关(Reflection)</span></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">3.1 描述一下JVM加载class文件的原理机制?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;JVM中类的装载是由ClassLoader和它的子类来实现的,它负责在运行时查找和装入类文件的类。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">类装载器把一个类装入Java虚拟机中，要经过三个步骤来完成：装载、链接和初始化，其中链接又可以分成校验、准备、解析装载：查找和导入类或接口的二进制数据；&nbsp;链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的；&nbsp;校验：检查导入类或接口的二进制数据的正确性；&nbsp;准备：给类的静态变量分配并初始化存储空间；&nbsp;解析：将符号引用转成直接引用；初始化：激活类的静态变量,初始化Java代码和静态Java代码块</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">3.2 Class.forName的作用?</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;调用该访问返回一个类名为指定字符串的类的对象。</span></p><div><br style=\"background-color: inherit;\"/><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 26px;\">五&nbsp;数组相关(Array)</span></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">5.1 数组有没有length()这个方法?&nbsp;String有没有length()这个方法？&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;数组没有length()这个方法，有length的属性。String有length()这个方法。&nbsp;</span></p><div><br style=\"background-color: inherit;\"/></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 26px; color: rgb(0, 112, 192);\">六&nbsp;&nbsp;&nbsp;集合相关(Collection)</span></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">6.1&nbsp;ArrayList、LinkedList、Vector、Stack区别&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Stack继承了Vector，所以区别同Vector。</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">内部实现方式：LinkedList是双向链表，其它是实用数组方式实现。</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">线程安全：Vector和Stack是线程安全，&nbsp;ArrayList和LinkedList非线程安全。</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">容量扩展（以java7为例）：</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">效率：查询，ArrayList可以通过下表直接定位元素，而LinkedList需要遍历链表，所以除了首尾元素的查询，ArrayList效率较高。</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp;插入，&nbsp;ArrayList插入元素时考虑到数组扩容和元素移位等操作，效率较低。</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp;修改，同查询。</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp;删除，&nbsp;指定位置的删除同插入情况，而清楚所有元素操作则都需要遍历故效率一样。</span></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">6.2 Hashtable&nbsp;和&nbsp;HashMap之间的区别</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">1.&nbsp;都实现了Map接口，Hashtable是线程安全的，HashMap非线程安全，hashMap速度较快一些。</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">2. HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。&nbsp;</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">3. HashMap允许null键值，Hashtable不允许。</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">4.&nbsp;HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</span></div><div>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">5.&nbsp;Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map&nbsp;interface的一个实现。</span></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">6.3 heap和stack有什么区别。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。堆是栈的一个组成元素&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">6.4 说出ArrayList,Vector,&nbsp;LinkedList的存储性能和特性&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">6.5 Collection&nbsp;和&nbsp;Collections的区别。</span><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Collection是集合类的上级接口，继承与他的接口主要有Set&nbsp;和List.&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Collections是针对集合类的一个工具类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">6.6 List,&nbsp;Set,&nbsp;Map是否继承自Collection接口?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;List，Set是，Map不是&nbsp;。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">6.7 Set里的元素是不能重复的，那么用什么方法来区分重复与否呢?&nbsp;是用==还是equals()?&nbsp;它们有何区别?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。&nbsp;equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">6.8 Collection框架中实现比较要实现什么接口</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;comparable/comparator</span></p><div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">6.9 Collection框架的结构</span></p></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">6.10 List&nbsp;和&nbsp;Map&nbsp;区别?</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;一个是存储单列数据的集合，另一个是存储键和值这样的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。</span></p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">6.11&nbsp;List、Map、Set三个接口，存取元素时，各有什么特点？ &nbsp;</span><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;首先，List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫Collection。Set里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象&nbsp;，即假设Set集合中有了一个A对象，现在我要向Set集合再存入一个B对象，但B对象与A对象equals相等，则B对象存储不进去，所以，Set集合的add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true，当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。Set取元素时，没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;List表示有先后顺序的集合，&nbsp;注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Obj&nbsp;e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(int&nbsp;index,Obj&nbsp;e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象，如图x所示。List除了可以以Iterator接口取得所有的元素，再逐一遍历各个元素之外，还可以调用get(index&nbsp;i)来明确说明取第几个。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;Map与List和Set不同，它是双列的集合，其中有put方法，定义如下：put(obj&nbsp;key,obj&nbsp;value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。取则可以根据key获得相应的value，即get(Object&nbsp;key)返回值为key&nbsp;所对应的value。另外，也可以获得所有的key的结合，还可以获得所有的value的结合，还可以获得key和value组合成的Map.Entry对象的集合。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;以特定次序来持有元素，可有重复元素。Set&nbsp;无法拥有重复元素,内部排序。Map&nbsp;保存key-value值，value可多值。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;HashSet按照hashcode值的某种运算方式进行存储，而不是直接按hashCode值的大小进行存储。例如，&quot;abc&quot;&nbsp;---&gt;&nbsp;78，&quot;def&quot;&nbsp;---&gt;&nbsp;62，&quot;xyz&quot;&nbsp;---&gt;&nbsp;65在hashSet中的存储顺序不是62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashSet按插入的顺序存储，那被存储对象的hashcode方法还有什么作用呢？学员想想!hashset集合比较两个对象是否相等，首先看hashcode方法是否相等，然后看equals方法是否相等。new&nbsp;两个Student插入到HashSet中，看HashSet的size，实现hashcode和equals方法后再看size。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;同一个对象可以在Vector中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往HashSet中却加不了多次的。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">6.12 说出ArrayList,Vector,&nbsp;LinkedList的存储性能和特性&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">6.13 TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;（应该是没有针对问题的确切的答案，当前的add方法放入的是哪个对象，就调用哪个对象的compareTo方法，至于这个compareTo方法怎么做，就看当前这个对象的类中是如何编写这个方法的）</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">6.14说出一些常用的类，包，接口，请各举5个&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">常用的类：BufferedReader&nbsp;&nbsp;BufferedWriter&nbsp;&nbsp;FileReader&nbsp;&nbsp;FileWirter&nbsp;&nbsp;String&nbsp;&nbsp;Integer&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">java.util.Date，System，Class，ArrayList,HashMap</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">常用的包：java.lang&nbsp;&nbsp;&nbsp;java.io&nbsp;&nbsp;java.util&nbsp;&nbsp;java.sql&nbsp;,javax.servlet,org.apache.strtuts.action,org.hibernate</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">常用的接口：Remote&nbsp;&nbsp;List&nbsp;&nbsp;Map&nbsp;&nbsp;Document&nbsp;&nbsp;NodeList&nbsp;,Servlet,HttpServletRequest,HttpServletResponse,Transaction(Hibernate)、&nbsp;&nbsp;&nbsp;&nbsp;Session(Hibernate),HttpSession</span></p><div><br style=\"background-color: inherit;\"/></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 26px;\">八&nbsp;相等性相关(&nbsp;equals,hashCode&nbsp;)</span></div><div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">8.1 short&nbsp;s1&nbsp;=&nbsp;1;&nbsp;s1&nbsp;=&nbsp;s1&nbsp;+&nbsp;1;有什么错?&nbsp;short&nbsp;s1&nbsp;=&nbsp;1;&nbsp;s1&nbsp;+=&nbsp;1;有什么错?&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">答：short&nbsp;s1&nbsp;=&nbsp;1;&nbsp;s1&nbsp;=&nbsp;s1&nbsp;+&nbsp;1;&nbsp;（s1+1运算结果是int型，需要强制转换类型）&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">short&nbsp;s1&nbsp;=&nbsp;1;&nbsp;s1&nbsp;+=&nbsp;1;（可以正确编译）</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">8.2 Math.round(11.5)等於多少?&nbsp;Math.round(-11.5)等於多少?&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Math.round(11.5)==12&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Math.round(-11.5)==-11&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">round方法返回与参数最接近的长整数，参数加1/2后求其floor.&nbsp;</span></p></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">8.3 swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;switch（expr1）中，expr1是一个整数或枚举表达式。因此传递给&nbsp;switch&nbsp;和&nbsp;case&nbsp;语句的参数应该是&nbsp;int、&nbsp;short、&nbsp;char&nbsp;或者&nbsp;byte。long,string&nbsp;都不能作用于swtich。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">8.4 用最有效率的方法算出2乘以8等於几?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&lt;&lt;&nbsp;3&nbsp;。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">8.5 两个对象值相同(x.equals(y)&nbsp;==&nbsp;true)，但却可有不同的hash&nbsp;code，这句话对不对?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;不对，有相同的hash&nbsp;code。</span></p></div><p>&nbsp; <span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">1) 对象相等则hashCode一定相等；<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;2) hashCode相等对象未必相等。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">8.6 char型变量中能不能存贮一个中文汉字?为什么?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的&nbsp;</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">8.7 简述逻辑操作(&amp;,|,^)与条件操作(&amp;&amp;,||)的区别。&nbsp;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;b.逻辑操作不会产生短路&nbsp;</span></p><div><div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">8.8 Integer与int的区别</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;另外，Integer提供了多个与整数相关的操作方法，例如，将一个字符串转换成整数，Integer中还定义了表示整数的最大值和最小值的常量。</span></p></div></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">8.9 Static变量是什么含义</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;static是静态变量,就是变量值不随函数执行结束而消失，下次调用同一函数时，上次所赋予的值仍存在。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">8.10 Java成员变量默认初始化的值。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;byte-0&nbsp;&nbsp;&nbsp;&nbsp;short-0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int-0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long-0L<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;char-&#39;\\u0000&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float-0.0F&nbsp;&nbsp;&nbsp;&nbsp;double-0.0D&nbsp;&nbsp;&nbsp;boolean-false<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;所有引用类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192); font-size: 22px;\">8.11 integer和long&nbsp;操作&nbsp;/和%&nbsp;的话，&nbsp;可能会抛出ArithmeticException，比如除0。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;但是&nbsp;float与double不会，即使是除以0。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;a=0;a=a/0;则a等于NaN。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">8.12 float型float&nbsp;f=3.4是否正确?&nbsp;</span><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;不正确。类型不匹配,应该用强制类型转换，如下所示：float&nbsp;f=3.4f;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(0, 112, 192);\">8.13 怎样取得小数点的前两位，并且进行四舍五入？</span></p><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;java.text.DecimalFormat&nbsp;&nbsp; df=new&nbsp;&nbsp; java.text.DecimalFormat(&quot;#.##&quot;);&nbsp;&nbsp;&nbsp;<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp; d=3.14159;&nbsp;&nbsp;&nbsp;<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(df.format(d));&nbsp;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;java.math.BigDecimal&nbsp;&nbsp;&nbsp;<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;BigDecimal&nbsp;&nbsp; bd&nbsp;&nbsp; =&nbsp;&nbsp; new&nbsp;&nbsp; BigDecimal(&quot;3.14159265&quot;);&nbsp;&nbsp;&nbsp;<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;bd&nbsp;&nbsp; =&nbsp;&nbsp; bd.setScale(2,BigDecimal.ROUND_HALF_UP);&nbsp;&nbsp;&nbsp;</span></div><div><br/></div><p><br style=\"background-color: inherit;\"/></p><div><div><div></div></div></div><p><br/></p>','Ken','1464707488003','Ken','1464707488003'),(19,'Java面试基础之Java基础知识（下）',1,'Overload和Override是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被\"屏蔽\"了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。','<div style=\"margin: 0px; white-space: normal; widows: auto; font-family: 微软雅黑; font-size: 14px; line-height: 21px; background-color: rgb(255, 255, 255);\"><div style=\"margin: 0px; background-color: inherit;\"><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 26px; color: rgb(84, 141, 212);\">十&nbsp;面向对象相关</span></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.1&nbsp;面向对象的特征有哪些方面?</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;抽象：包括过程抽象和数据抽象两个方面。（抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。）</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;多态：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</span></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.2&nbsp;int&nbsp;和&nbsp;Integer&nbsp;有什么区别&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;Java&nbsp;提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.3&nbsp;&amp;和&amp;&amp;的区别</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.4 Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写&nbsp;(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被&quot;屏蔽&quot;了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;是否可以改变返回值的类型这个问题要看问的是什么。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 如果参数列表不一样，它们的返回值类型可以不一样；</span></p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 如果参数列表一样，则不可以通过修改返回值来实现重载。例如Map里面的remove方法，通常我们不不需要它的返回值，加入有两个参数列表一样的remove方法，只是返回类型不一样，这是java程序就不知道我们要调用的是哪个方法了。</span><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;在覆盖时要注意：</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">4、被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.5 abstract&nbsp;class和interface有什么区别?</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px;\">&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;声明方法的存在而不去实现它的类被叫做抽象类（abstract&nbsp;class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract&nbsp;类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract&nbsp;类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获的。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static&nbsp;final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof&nbsp;运算符可以用来决定某对象的类是否实现了接口。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.6 什么是内部类？Static&nbsp;Nested&nbsp;Class&nbsp;和&nbsp;Inner&nbsp;Class的不同。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;内部类就是在一个类的内部定义的类，内部类中不能定义静态成员</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;1. 在方法体外面定义的内部类的访问类型可以是public,protecte,默认的，private等4种类型，这就好像类中定义的成员变量有4种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;2. 在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用final或abstract修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加final修饰符</span></p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;3.&nbsp;在方法外部定义的内部类前面可以加上static关键字，从而成为Static&nbsp;Nested&nbsp;Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static&nbsp;Nested&nbsp;Class与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成public、protected、默认的、private等多种类型，而普通类只能定义成public和默认的这两种类型。在外面引用Static&nbsp;Nested&nbsp;Class类的名称为“外部类名.内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建Static&nbsp;Nested&nbsp;Class，例如，假设Inner是定义在Outer类中的Static&nbsp;Nested&nbsp;Class，那么可以使用如下语句创建Inner类：</span><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Outer.Inner&nbsp;inner&nbsp;=&nbsp;new&nbsp;Outer.Inner();</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;由于static&nbsp;Nested&nbsp;Class不依赖于外部类的实例对象，所以，static&nbsp;Nested&nbsp;Class能访问外部类的非static成员变量。当在外部类中访问Static&nbsp;Nested&nbsp;Class时，可以直接使用Static&nbsp;Nested&nbsp;Class的名字，而不需要加上外部类的名字了，在Static&nbsp;Nested&nbsp;Class中也可以直接引用外部类的static的成员变量，不需要加上外部类的名字。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;在静态方法中定义的内部类也是Static&nbsp;Nested&nbsp;Class，这时候不能在类前面加static关键字，静态方法中的Static&nbsp;Nested&nbsp;Class与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的static的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加final修饰符。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Static&nbsp;Nested&nbsp;C</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; widows: auto; background-color: inherit;\">lass是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.7 接口是否可继承接口?&nbsp;抽象类是否可实现(implements)接口?&nbsp;抽象类是否可继承实体类(concrete&nbsp;class)?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.8 构造器Constructor是否可被override?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.9 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;是值传递。Java&nbsp;编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.10 Java的接口和C++的虚类的相同和不同处。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public&nbsp;static,所有方法默认情况下是public.一个类可以实现多个接口。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.11 Anonymous&nbsp;Inner&nbsp;Class&nbsp;(匿名内部类)&nbsp;是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;匿名的内部类是没有名字的内部类。不能extends(继承)&nbsp;其它类，但一个内部类可以作为一个接口，由另一个内部类实现。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.12 Static&nbsp;Nested&nbsp;Class&nbsp;和&nbsp;Inner&nbsp;Class的不同</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;Nested&nbsp;Class&nbsp;（一般是C++的说法），Inner&nbsp;Class&nbsp;(一般是JAVA的说法)。Java内部类与C++嵌套类最大的不同就在于是否有指向外部的引用上</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">静态内部类（Inner&nbsp;Class）意味着1创建一个static内部类的对象，不需要一个外部类对象，2不能从一个static内部类的一个对象访问一个外部类对象</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.13 静态变量和实例变量的区别？&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;语法定义上：静态变量前要加static关键字，而实例变量前则不加。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;程序运行时：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.14 是否可以从一个static方法内部发出对非static方法的调用？&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.15 请说出作用域public，private，protected，以及不写时的区别</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;如果在修饰的元素上面没有写任何访问修饰符，则表示friendly。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;作用域&nbsp;&nbsp;&nbsp;&nbsp;当前类&nbsp;同一package&nbsp;子孙类&nbsp;其他package&nbsp;</span></p><div><table cellpadding=\"2\" cellspacing=\"0\"><tbody style=\"background-color: inherit;\"><tr style=\"background-color: inherit;\" class=\"firstRow\"><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"36\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">作用域</span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"36\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">当前类</span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"115\" height=\"36\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">同一package</span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"83\" height=\"36\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">子孙类</span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"114\" height=\"36\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">其它package</span></td></tr><tr style=\"background-color: inherit;\"><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"31\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">public</span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"31\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"115\" height=\"31\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"83\" height=\"31\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"114\" height=\"31\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td></tr><tr style=\"background-color: inherit;\"><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"25\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">protected</span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"25\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"115\" height=\"25\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"83\" height=\"25\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"114\" height=\"25\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">×<br style=\"background-color: inherit;\"/></span></td></tr><tr style=\"background-color: inherit;\"><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">friendly</span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"115\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"83\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">×<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"114\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">×<br style=\"background-color: inherit;\"/></span></td></tr><tr style=\"background-color: inherit;\"><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">private</span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"99\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">√<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"115\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">×<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"83\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">×<br style=\"background-color: inherit;\"/></span></td><td valign=\"top\" style=\"padding-right: 16px; padding-left: 12px; border-collapse: collapse; border-color: rgb(153, 153, 153); word-break: break-all; min-height: 25px; min-width: 25px; background-color: inherit;\" width=\"114\" height=\"27\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">×<br style=\"background-color: inherit;\"/></span></td></tr></tbody></table></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.16 写clone()方法时，通常都有一行代码，是什么？&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;clone&nbsp;有缺省行为，super.clone();因为首先要把父类中的成员复制到位，然后才是复制自己的成员</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.17 java中实现多态的机制是什么？&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。&nbsp;</span></p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.18 内部类可以引用它的包含类的成员吗？有没有什么限制？&nbsp;</span><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;可以。如果不是静态内部类，那没有什么限制！&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.19 Anonymous&nbsp;Inner&nbsp;Class&nbsp;(匿名内部类)&nbsp;是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;可以继承其他类或实现其他接口。不仅是可以，而是必须!</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.20 super.getClass()方法调用</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;由于getClass()在Object类中定义成了final，子类不能覆盖该方法，所以，在</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; widows: auto; background-color: inherit;\">test方法中调用getClass().getName()方法，其实就是在调用从父类继承的getClass()方法，等效于调用super.getClass().getName()方法，所以，super.getClass().getName()方法返回的也应该是当前类名。</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">如果想得到父类的名称，应该用如下代码：</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;getClass().getSuperClass().getName();</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.21&nbsp;局部内部类是否可以访问非final变量？</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;不能访问局部的，可以访问成员变量（全局的）。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.22 普通内部类不可以拥有静态变量，但静态内部类可以。</span><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;File类没有&nbsp;任何&nbsp;处理文件内容的方法。InputStream&nbsp;和&nbsp;OutputStream&nbsp;是&nbsp;抽象类，&nbsp;DataInput&nbsp;和&nbsp;DataOutput是&nbsp;接口。DataInputStream实现了DataInput接口。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">10.23 Anonymous&nbsp;Inner&nbsp;Class&nbsp;(匿名内部类)&nbsp;是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?&nbsp;</span><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;可以继承其他类或完成其他接口，在swing编程中常用此方式。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.24 Java的接口和C++的虚类的相同和不同处。&nbsp;</span><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public&nbsp;static,所有方法默认情况下是public.一个类可以实现多个接口。&nbsp;<br style=\"background-color: inherit;\"/></span></p></div></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">10.25 匿名内部类是以什么方式实现的</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;第一种，继承一个类，重写其方法；第二种，实现一个接口（可以是多个），实现其方法。</span></p><p><br style=\"background-color: inherit;\"/></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 26px; color: rgb(84, 141, 212);\">十三&nbsp;其他(Others)</span></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.1 final,&nbsp;finally,&nbsp;finalize的区别。&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">finally是异常处理语句结构的一部分，表示总是执行。&nbsp;</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.2 GC是什么?&nbsp;为什么要有GC?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;GC是垃圾收集的意思（Gabage&nbsp;Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">13.3 Java有没有goto?&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;java中的保留字，现在没有在java中使用。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">13.4 垃圾回收的优点和原理。并考虑2种回收机制。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot;。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清理和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.5 什么时候用assert。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">　　断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为&nbsp;true。如果表达式计算为&nbsp;false，那么系统会报告一个&nbsp;AssertionError。它用于调试目的：</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">assert(a&nbsp;&gt;&nbsp;0);&nbsp;//&nbsp;throws&nbsp;an&nbsp;AssertionError&nbsp;if&nbsp;a&nbsp;&lt;=&nbsp;0</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">　　断言可以有两种形式：</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">assert&nbsp;Expression1&nbsp;;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">assert&nbsp;Expression1&nbsp;:&nbsp;Expression2&nbsp;;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Expression1&nbsp;应该总是产生一个布尔值。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Expression2&nbsp;可以是得出一个值的任意表达式。这个值用于生成显示更多调试信息的&nbsp;String&nbsp;消息。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">　　断言在默认情况下是禁用的。要在编译时启用断言，需要使用&nbsp;source&nbsp;1.4&nbsp;标记：</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">javac&nbsp;-source&nbsp;1.4&nbsp;Test.java</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">　　要在运行时启用断言，可使用&nbsp;-enableassertions&nbsp;或者&nbsp;-ea&nbsp;标记。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">　　要在运行时选择禁用断言，可使用&nbsp;-da&nbsp;或者&nbsp;-disableassertions&nbsp;标记。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">　　要系统类中启用断言，可使用&nbsp;-esa&nbsp;或者&nbsp;-dsa&nbsp;标记。还可以在包的基础上启用或者禁用断言。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">　　可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.6 XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？&nbsp;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;a:&nbsp;两种形式&nbsp;dtd，schema；</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;b:&nbsp;本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)；</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;c:有DOM,SAX,STAX等&nbsp;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问&nbsp;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;STAX:Streaming&nbsp;API&nbsp;for&nbsp;XML&nbsp;(StAX)&nbsp;</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.7 一个&quot;.java&quot;源文件中是否可以包括多个类（不是内部类）？有什么限制？&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.8 在JAVA中如何跳出当前的多重嵌套循环？&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;1. （不建议）在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break&nbsp;语句，即可跳出外层循环；</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;2. 在循环外卖设置一个boolean的标志flag，在外层循环时循环条件加上这个flag。</span></p><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">13.9 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？&nbsp;</span></span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;StringBuffer&nbsp;a=new&nbsp;StringBuffer(&quot;immutable&quot;);<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;执行如下语句将报告编译期错误：</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a=new&nbsp;StringBuffer(&quot;&quot;);<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;但是，执行如下语句则可以通过编译：</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.append(&quot;&nbsp;broken!&quot;);&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">public&nbsp;void&nbsp;method(final&nbsp;&nbsp;StringBuffer&nbsp;&nbsp;param){</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">}&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.append(&quot;a&quot;);</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">13.10 &quot;==&quot;和equals方法究竟有什么区别？</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet&nbsp;obj&nbsp;=&nbsp;new&nbsp;Object();变量obj是一个内存，new&nbsp;Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">String&nbsp;a=new&nbsp;String(&quot;foo&quot;);</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">String&nbsp;b=new&nbsp;String(&quot;foo&quot;);</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.11 描述一下JVM加载class文件的原理机制?&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;JVM中类的装载是由ClassLoader和它的子类来实现的,Java&nbsp;ClassLoader&nbsp;是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.12 heap和stack有什么区别。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;java的内存分为两类，一类是栈内存，一类是堆内存。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用final修饰后，放在堆中，而不是栈中。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.13 垃圾回收的优点和原理。并考虑2种回收机制。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有&quot;作用域&quot;的概念，只有对象的引用才有&quot;作用域&quot;。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">13.14 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是&quot;可达的&quot;，哪些对象是&quot;不可达的&quot;。当GC确定一些对象为&quot;不可达&quot;时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">13.15&nbsp;下面都是正确的main方法签名。</span></div><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">public&nbsp;static&nbsp;final&nbsp;void&nbsp;main(String[]&nbsp;args)</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">static&nbsp;public&nbsp;void&nbsp;main(String[]&nbsp;args)</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">static&nbsp;public&nbsp;synchronized&nbsp;void&nbsp;main(String[]&nbsp;args)</span></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">static&nbsp;public&nbsp;abstract&nbsp;void&nbsp;main(String[]&nbsp;args)//错误</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">13.16 数组，无论是当前的，还是类等级的，都会被初始化。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;String&nbsp;是被初始化为&nbsp;null,不是空字符。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;null,““,”&nbsp;“,都是不同的。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;“continue”只能在一个循环里(如for,do,while)，它不能在case语句中出现。<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;Primitive(int,char,long等)数组是不能互相赋值的，即使它们本身可以。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;一个Constructor可以抛出任何异常。<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;初始化块是按照声明的顺序执行的。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有关于&nbsp;NaN(Not&nbsp;a&nbsp;Number)&nbsp;和&nbsp;non-NaN&nbsp;的比较，都返回false.&nbsp;这条很重要。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==会产生编译错误，如果两边类型不匹配的话。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equals()&nbsp;返回&nbsp;false&nbsp;如果对象类型不同，但不产生&nbsp;编译错误。</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">13.17 串行化的注意事项以及如何实现串行化？</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;在java.io包中，接口Serializable用来作为实现对象串行化的工具，只有实现了Serializable的类的对象才可以被串行化。</span></p><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;1.串行化能保存的元素</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只能保存对象的非静态成员变量，不能保存任何的成员方法和静态的成员变量，而且串行化保存的只是变量的值，对于变量的任何修饰符，都不能保存。</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;2.transient关键字</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于某些类型的对象，其状态是瞬时的，这样的对象是无法保存其状态的，例如一个Thread对象，或一个FileInputStream对象，对于这些字段，我们必须用transient关键字标明</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;3. 定制串行化</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺省的串行化机制，对象串行化首先写入类数据和类字段的信息，然后按照名称的上升排列顺序写入其数值。如果想自己明确地控制这些数值的写入顺序和写入种类，必须定义自己的读取数据流的方式。就是在类的定义中重写writeObject()和readObject()方法。</span></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">13.18 Java的事件委托机制和垃圾回收机制</span></p><div><br/></div><p><br/></p>','Ken','1464709178637','Ken','1464709178637');
INSERT INTO `article` VALUES (20,'Java面试基础之Jsp、Servlet相关',1,'jsp的编译过程：在客户端第一次请求greeting.jsp时，Tomcat先将greeting.jsp转化为标准的java源代码greeting.jsp.java,存放在C：\\apache-tomcat-6.013\\work\\catalina\\locahost\\jsp\\or\\apache\\jsp目录下，并将greeting_jsp.java编译为类文件greetimg_jsp.class.该class文件便是jsp对应的servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问greeting.jsp时服务器将不再重新编译jsp文件而是直接调用greeting_jsp.class来响应客户端请求。由于jsp只会在客户端第一次请求的时候被编译，所以第一次请求时会比较慢，而后速度有所提升。如果将Tomcat保存的jsp编译后class文件删除，Tomcat也会重新编译jsp\n','<div style=\"font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; widows: auto; background-color: rgb(255, 255, 255);\"><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.1 JSP的工作原理和生命周期</span></p><p><strong><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">jsp的工作原理</span></strong><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>&nbsp;&nbsp;&nbsp;&nbsp;jsp是一种Servlet，但是与HttpServlet的工作方式不太一样。httpservlet是先由源代码编译为class文件后部署到服务器下的，先编译后部署。而jsp则是先部署后编译为class文件，先部署后编译jsp会在客户端第一次请求jsp文件时被编译为Httpjsppage类该类是Servlet的一个子类。该类会被服务器临时存放在服务器工作目录里面。<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>&nbsp;&nbsp;&nbsp;&nbsp;jsp的编译过程：在客户端第一次请求greeting.jsp时，Tomcat先将greeting.jsp转化为标准的java源代码greeting.jsp.java,存放在C：\\apache-tomcat-6.013(相关的版本号)\\work\\catalina\\locahost\\jsp\\or\\apache\\jsp目录下，并将greeting_jsp.java编译为类文件greetimg_jsp.class.该class文件便是jsp对应的servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问greeting.jsp时服务器将不再重新编译jsp文件而是直接调用greeting_jsp.class<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>来响应客户端请求。由于jsp只会在客户端第一次请求的时候被编译，所以第一次请求时会比较慢，而后速度有所提升。如果将Tomcat保存的jsp编译后class文件删除，Tomcat也会重新编译jsp<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/><strong>jsp的生命周期</strong><br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>&nbsp;&nbsp;&nbsp;&nbsp;jsp也是Servlet，运行时只会有一个实例。跟Servlet一样，jsp实例初始化，销毁时也会调用Servlet的init（）与destory()方法。另外其还有自己的初始化方法与销毁方法_jspInit()与_jspDestroy()<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>&nbsp;&nbsp;&nbsp;&nbsp;例如：<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>&lt;% page language =&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot;%&gt;<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>&lt;%public void _jspInit(){<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>相关初始化代码}<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>public void _Destroy(){<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>销毁时运行的代码}<br style=\"margin: 0px; padding: 0px; font-family: verdana, &#39;ms song&#39;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; line-height: 21.6px; white-space: normal; background-color: rgb(255, 255, 255);\"/>%&gt;&nbsp;</span></p></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.2 说出Servlet的生命周期，并说出Servlet和CGI的区别。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;答：Servlet的生命周期为&nbsp;实例化，初始化（init()），提供服务（service()），销毁（destroy()）</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</span></p><div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.3 JSP&nbsp;或&nbsp;Servlet&nbsp;中的&nbsp;forward&nbsp;和&nbsp;redirect&nbsp;有什么区别？</span><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\"><br style=\"background-color: inherit;\"/></span></div></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;转发是服务器端行为，重定向是客户端行为。</span></p><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;1.地址栏<br style=\"background-color: inherit;\"/></span><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</span></div></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;使用forward浏览器地址栏不变，redirect浏览器地址栏会改变</span></p><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;forward:转发页面和转发到的页面可以共享request里面的数据.<br style=\"background-color: inherit;\"/>&nbsp;&nbsp;&nbsp;&nbsp;redirect:不能共享数据</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;RequestDispatcher.forward方法只能将请求转发给同一个WEB应用中的组件；而 HttpServletResponse.sendRedirect 方法不仅可以重定向到当前应用程序中的其他资源，还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对URL重定向到其他站点的资源。</span></div><div><div><div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.4 在Servlet中，我们通过什么方法获取客户端提交的数据</span></p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">HttpServletRequest.getParameter()</span><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.5 在Servlet中，通过什么语句生成向客户端发送的页面？&nbsp;请编写一段简单的Hello&nbsp;World输出</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">PrintWriter&nbsp;out&nbsp;=&nbsp;response.getWriter(outputStream);</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Out.println(“Hello&nbsp;World!”);</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">1.6 请简述一下部署Serlvet的过程</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">把你项目的WebRoot文件夹拷贝到Tomcat的webapps文件夹下</span></p><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;servlet&gt;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp; &lt;servlet-name&gt;test&lt;/servlet-name&gt;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;/servlet&gt;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;servlet-mapping&gt;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp; &lt;servlet-name&gt;test&lt;/servlet-name&gt;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;/servlet-mapping&gt;</span></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.7 在JSP里声明一个变量的标记是？</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;%!%&gt; 定义类的成员变量&nbsp;例如：&lt;%!int&nbsp; i=0;%&gt;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;%%&gt; 定义本地方法的变量。<br style=\"background-color: inherit;\"/></span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.8 在一个JSP文档中，可以出现以下三种注释：</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">1)&nbsp;JSP注释标记&lt;%-- -%&gt;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">2)&nbsp;HTML注释&lt;!–&nbsp;–&gt;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.9 JSP的page指令常见的属性都有哪些？</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Language,&nbsp;contentType,&nbsp;import,&nbsp;errorPage,&nbsp;isErrorPage,&nbsp;extends,&nbsp;session,&nbsp;info,&nbsp;isThreadSafe,&nbsp;buffer,&nbsp;autoflush</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.10 假设需要在一个JSP页面里导入java.util.List,&nbsp;java.util.ArrayList,&nbsp;java.io.File，语句应该怎么写？</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;%@page&nbsp;import=”&nbsp;java.util.List,&nbsp;java.util.ArrayList,&nbsp;java.io.File”%&gt;</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">1.11&nbsp;若要导入footer.html&nbsp;页面，使用JSP的include指令应该如下导入？</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;%@include&nbsp;file=”footer.html”%&gt;</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.12 include与jsp:include区别</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;%@ include file=” ”%&gt;&nbsp;<br style=\"background-color: inherit;\"/>&lt;jsp:include page=” ” flush=”true”/&gt;&nbsp;</span></div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">执行时间上:&nbsp;<br style=\"background-color: inherit;\"/>&nbsp; &nbsp; include 是在翻译阶段执行&nbsp;<br style=\"background-color: inherit;\"/>&nbsp; &nbsp; jsp:include 在请求处理阶段执行.&nbsp;<br style=\"background-color: inherit;\"/>引入内容的不同:&nbsp;</span><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp; include&nbsp;引入静态文本(html,jsp),在JSP页面被转化成servlet之前和它融和到一起.&nbsp;</span><div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp; jsp:include 引入执行页面或servlet所生成的应答文本.&nbsp;</span><div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.13 在Servlet和JSP里是如何实现&nbsp;forward和redirect的？&nbsp;例如要跳转去一个test.jsp页面。</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">//Servlet</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">RequestDispatcher&nbsp;rd&nbsp;=&nbsp;this.getServletContext().getRequestDispatcher(“/test.jsp”);</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">rd.forward(request,&nbsp;response);</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">response.sendRedirect(“/test.jsp”);</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">//JSP</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;jsp:forward&nbsp;page=”/test.jsp&nbsp;”&nbsp;/&gt;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">response.sendRedirect(“/test.jsp”);</span></p></div></div></div></div></div></div></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.14 jsp主要内置对象有和作用？</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">九个内置对象：request、response和out、exception、session、application、config、pageContext和page</span></p><div><div><ul style=\"background-color: inherit;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">request对象</span></p></li></ul></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">request对象具有请求域,即完成客户端的请求之前,该对象一直有效。</span></div><div><ul style=\"background-color: inherit;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">response对象</span></p></li></ul></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">response对象具有页面作用域，即访问一个页面时，该页面内的response对象只能对这次访问有效，其它页面的response对象对当前页面无效。</span></div><div><ul style=\"background-color: inherit;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">session对象</span></p></li></ul></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">session对象指的是客户端与服务器的一次会话，从客户端连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例。</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">Session对象是一个JSP内置对象，它在第一个JSP页面被装载时自动创建，完成会话期管理。从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。当一个客户访问一个服务器时，可能会在这个服务器的几个页面之间切换，服务器应当通过某种办法知道这是同一个客户，就需要Session对象。</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">session对象具有会话作用域。</span></div><div><ul style=\"background-color: inherit;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">out对象</span></p></li></ul></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">out对象是JspWriter类的实例,是向客户端输出内容常用的对象</span></div><div><ul style=\"background-color: inherit;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">page对象</span></p></li></ul></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例</span></div><div><ul style=\"background-color: inherit;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">application对象</span></p></li></ul></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。</span></div><div><ul style=\"background-color: inherit;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">exception对象</span></p></li></ul></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象</span></div><div><ul style=\"background-color: inherit;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">pageContext对象</span></p></li></ul></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本类名也叫pageContext。</span></div><div><ul style=\"background-color: inherit;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">config对象</span></p></li></ul></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</span></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.15 内置对象产生的时机</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">一个JSP页面对应一个Servlet类，每个Servlet类有三个方法：<br style=\"background-color: inherit;\"/>　　init方法：初始化JSP/Servlet的方法。<br style=\"background-color: inherit;\"/>　　destroy方法：销毁JSP/Servlet的方法。<br style=\"background-color: inherit;\"/>　　service方法：对用户请求产生响应的方法。<br style=\"background-color: inherit;\"/>　　request对象和response对象是service方法的形参，application对象，page对象，out对象，pageContext对象，session对象都是service的方法中生成的实例。</span></div></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">1.16 在JSP里，我们可以怎样获取来自客户端请求的IP地址？</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">request.getRemoteAddr();</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.17 有一个用户名&nbsp;test,&nbsp;密码&nbsp;12345,&nbsp;请编写一段创建COOKIE的JSP代码,&nbsp;然后再编写一段读取COOKIE的JSP代码，&nbsp;在页面上将COOKIE的信息显示出来。</span></p><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;%</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;str&nbsp;=&nbsp;&quot;username=Tome&amp;password=123&quot;;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;Cookie&nbsp;cookie&nbsp;=&nbsp;new&nbsp;Cookie(&quot;user&quot;,&nbsp;str);</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;response.addCookie(cookie);</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;Cookie[]&nbsp;c&nbsp;=&nbsp;request.getCookies();</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;c.length;&nbsp;i++)&nbsp;{</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.print(c[i].getName()&nbsp;+&nbsp;&quot;&nbsp;-&nbsp;&quot;&nbsp;+&nbsp;c[i].getValue());</span></div><div><div><div><div><div><div><div><div><div><div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp; &nbsp; }</span></div></div></div></div></div></div></div></div></div></div></div><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.18 请简述Cookie,&nbsp;Session&nbsp;和Application它们的区别。</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">1)&nbsp;Cookie会在客户端硬盘上创建Cookie文件</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">2)&nbsp;Session大部分情况下会在服务器端硬盘上写入Cookie文件</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">3)&nbsp;Cookie安全性最低</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">4)&nbsp;Application&nbsp;表示Servlet上下文环境，在整个WEB应用中只有一个Application对象，用于存储些全局性的数据</span></p><p><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.19 如何现实servlet的单线程模式&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;%@&nbsp;page&nbsp;isThreadSafe=&quot;false&quot;%&gt;&nbsp;</span></p><div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.20 四种会话跟踪技术&nbsp;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">会话作用域Servlet&nbsp;JSP&nbsp;页面描述&nbsp;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;page否是代表与一个页面相关的对象和属性。一个页面由一个编译好的&nbsp;Java&nbsp;servlet&nbsp;类（可以带有任何的&nbsp;include&nbsp;指令，但是没有&nbsp;include&nbsp;动作）表示。这既包括&nbsp;servlet&nbsp;又包括被编译成&nbsp;servlet&nbsp;的&nbsp;JSP&nbsp;页面</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;request是是代表与&nbsp;Web&nbsp;客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个&nbsp;Web&nbsp;组件（由于&nbsp;forward&nbsp;指令和&nbsp;include&nbsp;动作的关系）&nbsp;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;session是是代表与用于某个&nbsp;Web&nbsp;客户机的一个用户体验相关的对象和属性。一个&nbsp;Web&nbsp;会话可以也经常会跨越多个客户机请求&nbsp;</span></div><div><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;application是是代表与整个&nbsp;Web&nbsp;应用程序相关的对象和属性。这实质上是跨越整个&nbsp;Web&nbsp;应用程序，包括多个页面、请求和会话的一个全局作用域&nbsp;</span></div></div><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.21 JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？&nbsp;</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">JSP是Servlet技术的扩展，本质上是Servlet的简易方式，更强调应用的外表表达。JSP编译后是&quot;类servlet&quot;。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。JSP侧重于视图，Servlet主要用于控制逻辑。</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 22px; color: rgb(84, 141, 212);\">1.22 如何利用ServletContext和ServletConfig对象获得初始化参数</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">String&nbsp;psw&nbsp;=&nbsp;config.getInitParameter(&quot;psw&quot;);</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">ServletContext&nbsp;ss&nbsp;=&nbsp;config.getServletContext();</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">String&nbsp;ppp&nbsp;=&nbsp;ss.getInitParameter(&quot;name&quot;);</span></p><div><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(84, 141, 212); font-size: 22px;\">1.23 在表单中存在一组名称为checkbox1的多选框，如何才能取得这些多选框内的值？</span></div><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">在页面中用javaScript方式取值</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;script&gt;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;&nbsp;sss(){</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;str&nbsp;=&nbsp;document.getElementsByName(&quot;checkbox1&quot;);&nbsp;&nbsp;&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;checkValue&nbsp;=&nbsp;new&nbsp;Array();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var&nbsp;i=0;i&lt;str.length;i++){</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(str[i].checked){</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(str[i].value);</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">&lt;/script&gt;</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">在Servlet中取值</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">String&nbsp;str[]&nbsp;=&nbsp;request.getParameterValues(&quot;checkbox1&quot;);</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">在Servlet中完成正确接受中文及向显示页面响应的代码。试写一段程序&nbsp;，用来接收从SERVLET用POST和GET方法传来得中文参数</span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">public&nbsp;void&nbsp;service&nbsp;(HttpServletRequest&nbsp;request,HttpServletResponse&nbsp;response){}</span></p><p><br/></p>','Ken','1464881253973','Ken','1464881253973'),(21,'Java面试基础之多线程相关',1,'当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? \n分几种情况：\n1. 其他方法前是否加了synchronized关键字，如果没加，则能。     \n2. 如果这个方法内部调用了wait，则可以进入其他synchronized方法。\n3. 如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。\n4. 如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。','<p><span style=\"font-family: 微软雅黑; font-size: 22px; background-color: rgb(255, 255, 255);\">4.1&nbsp;<span style=\"background-color: inherit;\">多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?&nbsp;</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">多线程有两种实现方法，分别是继承<span style=\"background-color: inherit;\">Thread类与实现Runnable接口</span>。</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">同步的实现方面有两种，分别是<span style=\"background-color: inherit;\">synchronized,wait与notify&nbsp;。</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 22px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; background-color: inherit;\">4.2 sleep()&nbsp;和&nbsp;wait()&nbsp;有什么区别?&nbsp;</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。&nbsp;</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 12px; background-color: inherit;\">“sleep()<span style=\"background-color: inherit;\">方法是使线程停止一段时间的方法。在sleep时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其它线程可能正在运行而且没有被调度为放弃执行，除非(a)&nbsp;&quot;醒来&nbsp;&quot;的线程具有更高的优先级&nbsp;&nbsp;(b)正在运行的线程因为其它原因而阻塞。　wait()是线程交互时，如果线程对一个同步对象x发出一个wait()调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。”</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 16px; font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;\">sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 22px; background-color: inherit;\">4.2 同步和异步有何异同，在什么情况下分别使用他们？举例说明。&nbsp;</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。&nbsp;</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 22px; background-color: inherit;\">4.3 设计<span style=\"background-color: inherit;\">4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 22px; background-color: inherit;\">4.4 启动一个线程是用<span style=\"background-color: inherit;\">run()还是start()?</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">启动一个线程是调用<span style=\"background-color: inherit;\">start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行，这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 22px; background-color: inherit;\">4.5 abstract<span style=\"background-color: inherit;\">的method是否可同时是static,是否可同时是native，是否可同时是synchronized?&nbsp;</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">abstract的method&nbsp;不可以是static的，因为抽象的方法是要被子类实现的，而static与子类扯不上关系！</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">native方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与abstract混用。例如，FileOutputSteam类要硬件打交道，底层的实现用的是操作系统相关的api实现，例如，在windows用c语言实现的，所以，查看jdk&nbsp;的源代码，可以发现FileOutputStream的open方法的定义如下：</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">private&nbsp;native&nbsp;void&nbsp;open(String&nbsp;name)&nbsp;throws&nbsp;FileNotFoundException;</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">如果我们要用java调用别人写的c语言函数，我们是无法直接调用的，我们需要按照java的要求写一个c语言的函数，又我们的这个c语言函数去调用别人的c语言函数。由于我们的c语言函数是按java的要求来写的，我们这个c语言函数就可以与java对接上，java那边的对接方式就是定义出与我们这个c函数相对应的方法，java中对应的方法不需要写具体的代码，但需要在前面声明native。</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">关于synchronized与abstract合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得synchronized应该是作用在一个具体的方法上才有意义。而且，方法上的synchronized同步所使用的同步锁对象是this，而抽象方法上无法确定this是什么。&nbsp;</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><br style=\"background-color: inherit;\"/></p><p><span style=\"font-family: 微软雅黑; font-size: 22px; background-color: rgb(255, 255, 255);\">4.6&nbsp;<span style=\"background-color: inherit;\">请说出你所知道的线程同步的方法。&nbsp;</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">wait():使一个线程处于等待状态，并且释放所持有的对象的lock。&nbsp;</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">sleep():<span style=\"background-color: inherit;\">使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法</span>不会释放对象锁要捕捉<span style=\"background-color: inherit;\">InterruptedException异常。&nbsp;</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">notify():<span style=\"background-color: inherit;\">唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。&nbsp;</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">Allnotity():<span style=\"background-color: inherit;\">唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</span></span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-size: 22px; background-color: inherit;\">4.7 线程的基本概念、线程的基本状态以及状态之间的关系&nbsp;</span></p><p style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\">线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。&nbsp;<span style=\"background-color: inherit;\">Java中的线程有四种状态分别是：运行、就绪、挂起、结束。</span></span></p><div style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><div style=\"background-color: inherit;\"><span style=\"font-size: 22px; background-color: inherit;\">4.8 简述synchronized和java.util.concurrent.locks.Lock的异同&nbsp;？&nbsp;</span></div><div style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">主要相同点：Lock能完成synchronized所实现的所有功能&nbsp;</span></div><div style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</span></div></div><div style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\"><div style=\"background-color: inherit;\"><span style=\"font-size: 22px; background-color: inherit;\"><span style=\"background-color: inherit;\">4.9 java中有几种方法可以实现一个线程？用什么关键字修饰同步方法?&nbsp;stop()和suspend()</span>方法为何不推荐使用？</span>&nbsp;</div><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">1.&nbsp;new&nbsp;Thread(){public&nbsp;void&nbsp;run(){}}.start();</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">2.&nbsp;new&nbsp;Thread(new&nbsp;Runnable(){public&nbsp;void&nbsp;run(){}}).start();</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">3. ExecutorService&nbsp;pool&nbsp;=&nbsp;Executors.newFixedThreadPool(3)</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">for(int&nbsp;i=0;i&lt;10;i++){</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">&nbsp;pool.execute(new&nbsp;Runable(){public&nbsp;void&nbsp;run(){}});</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">}</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">Executors.newCachedThreadPool().execute(new&nbsp;Runable(){public&nbsp;void&nbsp;run(){}});</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">Executors.newSingleThreadExecutor().execute(new&nbsp;Runable(){public&nbsp;void&nbsp;run(){}});</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">有两种实现方法，分别是继承Thread类与实现Runnable接口&nbsp;</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">用synchronized关键字修饰同步方法&nbsp;</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被&quot;挂起&quot;的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。&nbsp;</span></p></span></div><div style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\"><div style=\"background-color: inherit;\"><span style=\"font-size: 22px; background-color: inherit;\">4.10 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?&nbsp;</span></div><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">分几种情况：</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">1. 其他方法前是否加了synchronized关键字，如果没加，则能。&nbsp; &nbsp; &nbsp;</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">2. 如果这个方法内部调用了wait，则可以进入其他synchronized方法。</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">3. 如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">4. 如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</span></p></span></div><div style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"background-color: inherit;\"><div style=\"background-color: inherit;\"><span style=\"font-size: 22px; background-color: inherit;\">4.11 线程的基本概念、线程的基本状态以及状态之间的关系&nbsp;</span></div><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，它怎么能够同时执行多段程序呢？这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a,b在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。&nbsp;</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">状态：就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。</span></p></span></div><div style=\"font-family: 微软雅黑; white-space: normal; background-color: rgb(255, 255, 255);\"><div style=\"background-color: inherit;\"><span style=\"background-color: inherit;\"><div style=\"background-color: inherit;\"><div style=\"background-color: inherit;\"><span style=\"font-size: 22px; background-color: inherit;\">4.12 简述synchronized和java.util.concurrent.locks.Lock的异同&nbsp;？&nbsp;</span></div><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">主要相同点：Lock能完成synchronized所实现的所有功能&nbsp;</span></p><p style=\"background-color: inherit;\"><span style=\"background-color: inherit;\">主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。</span></p><div><span style=\"background-color: inherit;\"><br/></span></div></div></span></div></div><p><br/></p>','Ken','1464969076955','Ken','1464969076955'),(22,'System.nanoTime和System.currentTimeMillis',1,'System.nanoTime提供相对精确的计时，但是不能用他来计算当前日期； System.currentTimeMillis返回的是从1970.1.1 UTC 零点开始到现在的时间，精确到毫秒，可以根据它来计算当前日期','<pre class=\"brush:java;toolbar:false;\" style=\"font-family: Monaco, Consolas, Courier, &#39;Lucida Console&#39;, monospace; font-size: 14px; line-height: 21px; background-color: rgb(255, 255, 255);\">public&nbsp;static&nbsp;native&nbsp;long&nbsp;nanoTime();</pre><h1 label=\"标题居左\" style=\"font-size: 32px; font-weight: bold; border-bottom-color: rgb(204, 204, 204); border-bottom-width: 2px; border-bottom-style: solid; padding: 0px 4px 0px 0px; text-align: left; margin: 0px 0px 10px;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; line-height: 21px; background-color: rgb(255, 255, 255);\">System.nanoTime提供相对精确的计时，但是不能用他来计算当前日期</span></span></h1><p style=\"font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">返回最准确的可用系统计时器的当前值，以毫微秒为单位。</span></p><p style=\"font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">此方法只能用于测量已过的时间，与系统或钟表时间的其他任何时间概念无关。返回值表示从某一固定但任意的时间算起的毫微秒数（或许从以后算起，所以该值可能为负）。此方法提供毫微秒的精度，但不是必要的毫微秒的准确度。它对于值的更改频率没有作出保证。在取值范围大于约 292 年（263&nbsp;毫微秒）的连续调用的不同点在于：由于数字溢出，将无法准确计算已过的时间。</span></p><div style=\"font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; background-color: rgb(255, 255, 255);\"><div style=\"background-color: inherit;\"><div style=\"background-color: inherit;\"><p style=\"background-color: inherit;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">返回：</span></p></div><ul class=\" list-paddingleft-2\" style=\"list-style-type: disc;\"><li><div style=\"background-color: inherit;\"><p style=\"background-color: inherit;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">系统计时器的当前值，以毫微秒为单位。</span></p></div></li><li><div style=\"background-color: inherit;\"><p style=\"background-color: inherit;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">从以下版本开始：</span><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">1.5</span></p></div></li></ul><p style=\"background-color: inherit;\"><br/></p></div></div><p style=\"font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\"></span></p><pre class=\"brush:java;toolbar:false;\" style=\"font-family: Monaco, Consolas, Courier, &#39;Lucida Console&#39;, monospace; font-size: 14px; line-height: 21px; background-color: rgb(255, 255, 255);\">public&nbsp;static&nbsp;native&nbsp;long&nbsp;currentTimeMillis();</pre><div style=\"font-family: 微软雅黑; font-size: 14px; line-height: 21px; white-space: normal; background-color: rgb(255, 255, 255);\"><div style=\"background-color: inherit;\"><h1 label=\"标题居左\" style=\"font-size: 32px; font-weight: bold; border-bottom-color: rgb(204, 204, 204); border-bottom-width: 2px; border-bottom-style: solid; padding: 0px 4px 0px 0px; text-align: left; margin: 0px 0px 10px;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; line-height: 21px; background-color: rgb(255, 255, 255);\">System.currentTimeMillis返回的是从1970.1.1 UTC 零点开始到现在的时间，精确到毫秒，可以根据它来计算当前日期</span></span></h1><p style=\"background-color: inherit;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">返回以毫秒为单位的当前时间。注意，当返回值的时间单位是毫秒时，值的粒度取决于底层操作系统，并且粒度可能更大。例如，许多操作系统以几十毫秒为单位测量时间。</span></p></div><div style=\"background-color: inherit;\"><div style=\"background-color: inherit;\"><p style=\"background-color: inherit;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">返回：</span></p></div><ul class=\" list-paddingleft-2\" style=\"list-style-type: disc;\"><li><div style=\"background-color: inherit;\"><p style=\"background-color: inherit;\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px; background-color: inherit;\">当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）。</span></p></div></li></ul><p style=\"background-color: inherit;\"><br style=\"background-color: inherit;\"/></p></div></div><p><br/></p>','Ken','1465055426865','Ken','1465055426865');

#
# Structure for table "article_tags"
#

DROP TABLE IF EXISTS `article_tags`;
CREATE TABLE `article_tags` (
  `articleId` int(20) NOT NULL,
  `tagId` int(20) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

#
# Data for table "article_tags"
#

INSERT INTO `article_tags` VALUES (2,7),(5,10),(5,9),(1,6),(7,1),(13,12),(12,12),(9,12),(8,12),(3,11),(14,3),(11,3),(10,3),(4,3),(15,3),(21,13),(20,13),(19,13),(18,13),(22,1);

#
# Structure for table "butuidetail"
#

DROP TABLE IF EXISTS `butuidetail`;
CREATE TABLE `butuidetail` (
  `butuiId` int(64) NOT NULL AUTO_INCREMENT,
  `attendanceId` int(64) NOT NULL,
  `butuiDate` datetime NOT NULL,
  `type` int(11) NOT NULL,
  `amount` decimal(10,2) NOT NULL,
  `remark` varchar(128) DEFAULT NULL,
  `creator` varchar(32) NOT NULL,
  `createDate` datetime NOT NULL,
  PRIMARY KEY (`butuiId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='补退';

#
# Data for table "butuidetail"
#


#
# Structure for table "checkingattendance"
#

DROP TABLE IF EXISTS `checkingattendance`;
CREATE TABLE `checkingattendance` (
  `attendanceId` int(64) NOT NULL AUTO_INCREMENT,
  `beLate` float DEFAULT NULL,
  `leaveEarly` float DEFAULT NULL,
  `lackOfTime` int(11) DEFAULT NULL,
  `personalLeave` float DEFAULT NULL,
  `sickLeave` float DEFAULT NULL,
  `lactationLeave` float DEFAULT NULL,
  `peacetimeOvertime` float DEFAULT NULL,
  `weekendWork` float DEFAULT NULL,
  `holidayOvertime` float DEFAULT NULL,
  `absenteeism` float DEFAULT NULL,
  `consume` decimal(10,2) DEFAULT NULL,
  `variationDate` datetime DEFAULT NULL,
  `variationDetail` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`attendanceId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='考勤';

#
# Data for table "checkingattendance"
#


#
# Structure for table "clicks"
#

DROP TABLE IF EXISTS `clicks`;
CREATE TABLE `clicks` (
  `articleId` int(20) NOT NULL,
  `clicks` int(32) NOT NULL,
  UNIQUE KEY `articleId` (`articleId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

#
# Data for table "clicks"
#

INSERT INTO `clicks` VALUES (1,347),(2,893),(3,119),(4,82),(5,1113),(7,458),(8,34),(9,22),(10,55),(11,62),(12,26),(13,43),(14,58),(15,63),(18,973),(19,206),(20,271),(21,982),(22,204);

#
# Structure for table "comments"
#

DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments` (
  `commentId` int(20) NOT NULL AUTO_INCREMENT,
  `articleId` int(20) DEFAULT '-1',
  `content` varchar(5000) NOT NULL,
  `status` int(11) NOT NULL DEFAULT '1',
  `createTime` mediumtext NOT NULL,
  PRIMARY KEY (`commentId`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4;

#
# Data for table "comments"
#

INSERT INTO `comments` VALUES (1,1,'<p><img src=\"http://img.baidu.com/hi/jx2/j_0001.gif\"/></p>',1,'1450100558502'),(2,1,'<p>hello&nbsp;<img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/></p>',1,'1450101213673'),(3,3,'<p>testing</p>',1,'1451462248532'),(4,1,'<p>hi blog<img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/></p>',1,'1451481543255'),(5,3,'<p>234</p>',1,'1452241225479'),(6,2,'<p>sf</p>',1,'1452493571220'),(7,8,'<p>123</p>',1,'1453713946399'),(8,12,'<ol class=\" list-paddingleft-2\" style=\"list-style-type: decimal;\"><li><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">建一个新链表，把输入的两个链表从头往后每两个数字相加然后放入新链表中。</span></p></li><li><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">要注意的是相加的进位要累加到下一个节点的两个数相加。遍历计算之后如果存在进位，要注意处理。</span></p></li><li><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最后，返回的不是链表的最后一个节点。</span></p></li><li><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"></p></li></ol><ul class=\" list-paddingleft-2\" style=\"list-style-type: disc;\"><li><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">建一个新链表，把输入的两个链表从头往后每两个数字相加然后放入新链表中。</span></p></li><li><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">要注意的是相加的进位要累加到下一个节点的两个数相加。遍历计算之后如果存在进位，要注意处理。</span></p></li><li><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最后，返回的不是链表的最后一个节点。</span></p></li></ul><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"></span></p><pre class=\"brush:plain;toolbar:false\">建一个新链表，把输入的两个链表从头往后每两个数字相加然后放入新链表中。\n要注意的是相加的进位要累加到下一个节点的两个数相加。遍历计算之后如果存在进位，要注意处理。\n最后，返回的不是链表的最后一个节点。</pre><blockquote><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"><br/></span></p><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">建一个新链表，把输入的两个链表从头往后每两个数字相加然后放入新链表中。</span></p><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">要注意的是相加的进位要累加到下一个节点的两个数相加。遍历计算之后如果存在进位，要注意处理。</span></p><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\">最后，返回的不是链表的最后一个节点。</span></p></blockquote><p style=\"margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); font-family: &#39;Open Sans&#39;, Helvetica, Arial, sans-serif; font-size: 14px; line-height: 20px; white-space: normal; background-color: rgb(255, 255, 255);\"><br/><span style=\"font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; font-size: 16px;\"></span></p><p><br/></p>',1,'1456585716783'),(9,15,'<p><img src=\"http://img.baidu.com/hi/jx2/j_0002.gif\"/></p>',1,'1458566862283');

#
# Structure for table "dict"
#

DROP TABLE IF EXISTS `dict`;
CREATE TABLE `dict` (
  `dictId` int(11) NOT NULL AUTO_INCREMENT,
  `dictType` varchar(32) DEFAULT NULL,
  `dictCode` varchar(32) DEFAULT NULL,
  `dictKey` int(32) DEFAULT NULL,
  `dictValue` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`dictId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

#
# Data for table "dict"
#


#
# Structure for table "login_account"
#

DROP TABLE IF EXISTS `login_account`;
CREATE TABLE `login_account` (
  `id` int(128) NOT NULL AUTO_INCREMENT,
  `account_name` varchar(64) NOT NULL,
  `password` varchar(64) NOT NULL,
  `role` int(1) NOT NULL,
  `mobile_phone` varchar(32) DEFAULT NULL,
  `sex` int(1) DEFAULT NULL COMMENT '0-女\n            1-男',
  `nickname` varchar(64) DEFAULT NULL,
  `headimgurl` varchar(512) DEFAULT NULL,
  `country` varchar(64) DEFAULT NULL,
  `city` varchar(64) DEFAULT NULL,
  `province` varchar(64) DEFAULT NULL,
  `create_time` datetime NOT NULL,
  `status` int(1) NOT NULL COMMENT '0-无效\n            1-有效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;

#
# Data for table "login_account"
#

INSERT INTO `login_account` VALUES (1,'admin','9qt%2BCzM5rKaD3y2iRrDekwjRK5NhGCM%2F',1,NULL,NULL,NULL,NULL,NULL,NULL,NULL,'2015-12-14 00:37:58',1);

#
# Structure for table "login_log"
#

DROP TABLE IF EXISTS `login_log`;
CREATE TABLE `login_log` (
  `logId` int(11) NOT NULL AUTO_INCREMENT,
  `loginAccount` int(64) DEFAULT NULL,
  `loginType` int(2) DEFAULT NULL COMMENT '1-登录\n            2-主动退出\n            3-被动退出',
  `oprTime` datetime DEFAULT NULL,
  `ip` varchar(64) DEFAULT NULL,
  `os` varchar(64) DEFAULT NULL,
  `browser` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`logId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

#
# Data for table "login_log"
#


#
# Structure for table "salarysheet"
#

DROP TABLE IF EXISTS `salarysheet`;
CREATE TABLE `salarysheet` (
  `salaryId` int(128) NOT NULL AUTO_INCREMENT,
  `standardWage` decimal(10,2) NOT NULL,
  `postWage` decimal(10,2) NOT NULL,
  `floatingWage` decimal(10,2) NOT NULL,
  `actualFloating` decimal(10,2) NOT NULL,
  `overtimePay` decimal(10,2) NOT NULL,
  `communicationAllowance` decimal(10,2) NOT NULL,
  `preTaxCompensation` decimal(10,2) NOT NULL,
  `total` decimal(10,2) NOT NULL,
  `checkingAttendance` decimal(10,2) NOT NULL,
  `taxableSalary` decimal(10,2) NOT NULL,
  `socialInsuranceAmount` decimal(10,2) NOT NULL,
  `partOfTheFundCompany` decimal(10,2) NOT NULL,
  `providentFundIndividualPart` decimal(10,2) NOT NULL,
  `taxBase` decimal(10,2) NOT NULL,
  `tax` decimal(10,2) NOT NULL,
  `bail` decimal(10,2) NOT NULL,
  `taxRefund` decimal(10,2) NOT NULL,
  `consumptionAmount` decimal(10,2) NOT NULL,
  `actualWage` decimal(10,2) NOT NULL,
  `salaryDate` datetime NOT NULL,
  `createDate` datetime NOT NULL,
  `lastUpdDate` datetime NOT NULL,
  PRIMARY KEY (`salaryId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

#
# Data for table "salarysheet"
#


#
# Structure for table "statistics"
#

DROP TABLE IF EXISTS `statistics`;
CREATE TABLE `statistics` (
  `id` int(20) NOT NULL AUTO_INCREMENT,
  `type` varchar(12) NOT NULL,
  `result` int(10) NOT NULL DEFAULT '0',
  `statisticalTime` mediumtext NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

#
# Data for table "statistics"
#


#
# Structure for table "subject"
#

DROP TABLE IF EXISTS `subject`;
CREATE TABLE `subject` (
  `subjectId` int(20) NOT NULL AUTO_INCREMENT,
  `articleId` int(20) NOT NULL,
  `difficulty` int(11) NOT NULL,
  `timeLimit` int(11) NOT NULL,
  `memoryLimit` int(11) NOT NULL,
  `otherLimit` varchar(256) DEFAULT NULL,
  PRIMARY KEY (`subjectId`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4;

#
# Data for table "subject"
#

INSERT INTO `subject` VALUES (1,0,0,0,0,NULL),(2,0,0,0,0,NULL),(3,0,0,0,0,NULL),(4,0,0,0,0,NULL),(5,0,0,0,0,NULL);

#
# Structure for table "tag"
#

DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `tagId` int(20) NOT NULL AUTO_INCREMENT,
  `tagName` varchar(64) NOT NULL,
  `tagType` int(11) NOT NULL,
  PRIMARY KEY (`tagId`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4;

#
# Data for table "tag"
#

INSERT INTO `tag` VALUES (1,'Java',1),(2,'数据结构',1),(3,'算法',1),(4,'Apache Spark',1),(5,'JS',1),(6,'编译原理',1),(7,'Effective Java',1),(8,'字符串',2),(9,'服务器',1),(10,'问题',1),(11,'计蒜客',2),(12,'LeetCode',2),(13,'笔试面试',1),(14,'Git',1);
